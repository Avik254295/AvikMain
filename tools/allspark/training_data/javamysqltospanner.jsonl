{"input_text": "convert following Java code from MySQL to Spanner \npackage com.smattme;\r\n\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\n\r\nimport javax.mail.*;\r\nimport javax.mail.internet.InternetAddress;\r\nimport javax.mail.internet.MimeBodyPart;\r\nimport javax.mail.internet.MimeMessage;\r\nimport javax.mail.internet.MimeMultipart;\r\nimport java.io.File;\r\nimport java.util.Properties;\r\n\r\n/**\r\n * Created by seun_ on 25-Feb-18.\r\n *\r\n */\r\nclass EmailService {\r\n\r\n    private String host = \"\";\r\n    private int port = 0;\r\n    private String fromAdd = \"\";\r\n    private String toAdd = \"\";\r\n    private String username = \"\";\r\n    private String password = \"\";\r\n    private String subject = \"\";\r\n    private String msg = \"\";\r\n    private File [] attachments;\r\n    private Logger logger = LoggerFactory.getLogger(EmailService.class);\r\n    private final String LOG_PREFIX = \"java-mysql-exporter\";\r\n\r\n\r\n    private EmailService() {}\r\n\r\n    /**\r\n     * This is used to instantiate this class and form a\r\n     * builder pattern\r\n     * @return EmailService a new instance of this class\r\n     */\r\n    static EmailService builder() {\r\n        return new EmailService();\r\n    }\r\n\r\n    EmailService setHost(String host){\r\n        this.host = host;\r\n        return this;\r\n    }\r\n\r\n    EmailService setPort(int port) {\r\n        this.port = port;\r\n        return this;\r\n    }\r\n\r\n    EmailService setFromAddress(String fromAdd) {\r\n        this.fromAdd = fromAdd;\r\n        return this;\r\n    }\r\n\r\n    EmailService setToAddress(String toAdd) {\r\n        this.toAdd = toAdd;\r\n        return  this;\r\n    }\r\n\r\n    EmailService setUsername(String username) {\r\n        this.username = username;\r\n        return this;\r\n    }\r\n\r\n    EmailService setPassword(String password) {\r\n        this.password = password;\r\n        return this;\r\n    }\r\n\r\n    EmailService setSubject(String subject) {\r\n        this.subject = subject;\r\n        return this;\r\n    }\r\n\r\n    EmailService setMessage(String message) {\r\n        this.msg = message;\r\n        return this;\r\n    }\r\n\r\n    EmailService setAttachments(File[] files) {\r\n        this.attachments = files;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * This will check if the necessary properties\r\n     * are set for sending an email successfully\r\n     * @return boolean\r\n     */\r\n    private boolean isPropertiesSet() {\r\n        return !this.host.isEmpty() &&\r\n                this.port > 0 &&\r\n                !this.username.isEmpty() &&\r\n                !this.password.isEmpty() &&\r\n                !this.toAdd.isEmpty() &&\r\n                !this.fromAdd.isEmpty() &&\r\n                !this.subject.isEmpty() &&\r\n                !this.msg.isEmpty() &&\r\n                this.attachments != null && this.attachments.length > 0;\r\n    }\r\n\r\n\r\n    /**\r\n     * This function will send an email\r\n     * and add the generated sql file as an attachment\r\n     * @return boolean\r\n     */\r\n    boolean sendMail() {\r\n\r\n        if(!this.isPropertiesSet()) {\r\n            logger.debug(LOG_PREFIX + \": Required Mail Properties are not set. Attachments will not be sent\");\r\n            return false;\r\n        }\r\n\r\n        Properties prop = new Properties();\r\n        prop.put(\"mail.smtp.auth\", true);\r\n        prop.put(\"mail.smtp.starttls.enable\", \"true\");\r\n        prop.put(\"mail.smtp.host\", this.host);\r\n        prop.put(\"mail.smtp.port\", this.port);\r\n        prop.put(\"mail.smtp.ssl.trust\", host);\r\n\r\n        logger.debug(LOG_PREFIX + \": Mail properties set\");\r\n\r\n        Session session = Session.getInstance(prop, new Authenticator() {\r\n            @Override\r\n            protected PasswordAuthentication getPasswordAuthentication() {\r\n                return new PasswordAuthentication(username, password);\r\n            }\r\n        });\r\n\r\n        logger.debug(LOG_PREFIX + \": Mail Session Created\");\r\n\r\n        try {\r\n//\t\t\tcreate a default mime message object\r\n            Message message = new MimeMessage(session);\r\n            message.setFrom(new InternetAddress(fromAdd));\r\n            message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(toAdd));\r\n            message.setSubject(subject);\r\n\r\n//          body part for message\r\n            MimeBodyPart mimeBodyPart = new MimeBodyPart();\r\n            mimeBodyPart.setContent(msg, \"text/html\");\r\n\r\n//          body part for attachments\r\n            MimeBodyPart attachmentBodyPart = new MimeBodyPart();\r\n            logger.debug(LOG_PREFIX + \": \" + this.attachments.length + \" attachments found\");\r\n            for (File file: this.attachments) {\r\n                attachmentBodyPart.attachFile(file);\r\n            }\r\n\r\n//          create a multipart to combine them together\r\n            Multipart multipart = new MimeMultipart();\r\n            multipart.addBodyPart(mimeBodyPart);\r\n            multipart.addBodyPart(attachmentBodyPart);\r\n\r\n            //now set the multipart as the content of the message\r\n            message.setContent(multipart);\r\n\r\n//\t\t\tsend the message\r\n            Transport.send(message);\r\n\r\n            logger.debug(LOG_PREFIX + \": MESSAGE SENT SUCCESSFULLY\");\r\n\r\n            return true;\r\n\r\n        } catch (Exception e) {\r\n            logger.debug(LOG_PREFIX + \": MESSAGE NOT SENT. \" + e.getLocalizedMessage());\r\n            e.printStackTrace();\r\n            return false;\r\n        }\r\n\r\n    }\r\n\r\n}", "output_text": "import com.google.cloud.spanner.*;\nimport org.apache.commons.csv.CSVFormat;\nimport org.apache.commons.csv.CSVPrinter;\n\nimport javax.mail.*;\nimport javax.mail.internet.InternetAddress;\nimport javax.mail.internet.MimeBodyPart;\nimport javax.mail.internet.MimeMessage;\nimport javax.mail.internet.MimeMultipart;\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.util.Properties;\n\npublic class SpannerExportService {\n\n    public static void main(String[] args) {\n        try {\n            exportAndEmail(\"your-instance-id\", \"your-database-id\", \"external/output.csv\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void exportAndEmail(String instanceId, String databaseId, String outputPath) throws Exception {\n        SpannerOptions options = SpannerOptions.newBuilder().build();\n        Spanner spanner = options.getService();\n        DatabaseClient dbClient = spanner.getDatabaseClient(DatabaseId.of(options.getProjectId(), instanceId, databaseId));\n\n        exportToCsv(dbClient, outputPath);\n\n        sendEmail(outputPath);\n\n        spanner.close();\n    }\n\n    private static void exportToCsv(DatabaseClient dbClient, String outputPath) throws IOException {\n        try (ResultSet resultSet = dbClient.singleUse().executeQuery(Statement.of(\"SELECT * FROM YourTable\"));\n             FileWriter out = new FileWriter(outputPath);\n             CSVPrinter printer = new CSVPrinter(out, CSVFormat.DEFAULT.withHeader(resultSet.getType().getStructType().getFields().stream()\n                     .map(StructField::getName).toArray(String[]::new)))) {\n\n            while (resultSet.next()) {\n                for (int i = 0; i < resultSet.getColumnCount(); i++) {\n                    printer.print(resultSet.getValue(i).getString());\n                }\n                printer.println();\n            }\n        }\n        System.out.println(\"Data exported to \" + outputPath);\n    }\n\n    private static void sendEmail(String filePath) throws MessagingException, IOException {\n        Properties emailProperties = new Properties();\n        emailProperties.put(\"mail.smtp.host\", \"smtp.mailtrap.io\");\n        emailProperties.put(\"mail.smtp.port\", \"25\");\n        emailProperties.put(\"mail.smtp.auth\", \"true\");\n\n        Session session = Session.getInstance(emailProperties, new Authenticator() {\n            @Override\n            protected PasswordAuthentication getPasswordAuthentication() {\n                return new PasswordAuthentication(\"mailtrap-username\", \"mailtrap-password\");\n            }\n        });\n\n        Message message = new MimeMessage(session);\n        message.setFrom(new InternetAddress(\"test@smattme.com\"));\n        message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(\"backup@smattme.com\"));\n        message.setSubject(\"Spanner Database Export\");\n\n        BodyPart messageBodyPart = new MimeBodyPart();\n        messageBodyPart.setText(\"Find the attached export of the Spanner database.\");\n\n        Multipart multipart = new MimeMultipart();\n        multipart.addBodyPart(messageBodyPart);\n\n        messageBodyPart = new MimeBodyPart();\n        messageBodyPart.attachFile(new File(filePath));\n        multipart.addBodyPart(messageBodyPart);\n\n        message.setContent(multipart);\n\n        Transport.send(message);\n\n        System.out.println(\"Email sent successfully with the attachment.\");\n    }\n}\n"}
{"input_text": "convert following Java code from MySQL to Spanner \npackage com.smattme;\r\n\r\nimport com.smattme.exceptions.MysqlBackup4JException;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\n\r\nimport java.sql.Connection;\r\nimport java.sql.SQLException;\r\nimport java.sql.Statement;\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.List;\r\n\r\n/**\r\n * Created by seun_ on 01-Mar-18.\r\n *\r\n */\r\npublic class MysqlImportService {\r\n\r\n    private String database;\r\n    private String username;\r\n    private String password;\r\n    private String sqlString;\r\n    private String jdbcConnString;\r\n    private String jdbcDriver;\r\n    private boolean deleteExisting;\r\n    private boolean dropExisting;\r\n    private List<String> tables;\r\n    private Logger logger = LoggerFactory.getLogger(MysqlImportService.class);\r\n\r\n    private MysqlImportService() {\r\n        this.deleteExisting = false;\r\n        this.dropExisting = false;\r\n        this.tables = new ArrayList<>();\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @return bool\r\n     * @throws SQLException exception\r\n     * @throws ClassNotFoundException exception\r\n     */\r\n    public boolean importDatabase() throws SQLException, ClassNotFoundException {\r\n\r\n        if(!this.assertValidParams()) {\r\n            String message = \"Required Parameters not set or empty \\n\" +\r\n                    \"Ensure database, username, password, sqlString params are configured \\n\" +\r\n                    \"using their respective setters\";\r\n            logger.error(message);\r\n            throw new MysqlBackup4JException(message);\r\n        }\r\n\r\n\r\n        //connect to the database\r\n        Connection connection;\r\n        if(jdbcConnString == null || jdbcConnString.isEmpty()) {\r\n            connection = MysqlBaseService.connect(username, password, database, jdbcDriver);\r\n        }\r\n        else {\r\n\r\n            //this prioritizes the value set using the setDatabase() over the one extracted from the connection string\r\n            //it will only use the one from the connection string if no value is set using the setDatabase()\r\n            if(database == null || database.isEmpty()) {\r\n                database = MysqlBaseService.extractDatabaseNameFromJDBCUrl(jdbcConnString);\r\n                logger.debug(\"database name extracted from connection string: \" + database);\r\n            }\r\n\r\n            connection = MysqlBaseService.connectWithURL(username, password, jdbcConnString, jdbcDriver);\r\n        }\r\n\r\n        Statement stmt = connection.createStatement();\r\n\r\n         if(deleteExisting || dropExisting) {\r\n\r\n            //get all the tables, so as to eliminate delete errors due to non-existent tables\r\n             TablesResponse allTablesAndViews = MysqlBaseService.getAllTablesAndViews(database, stmt);\r\n             tables = allTablesAndViews.getTables();\r\n             logger.debug(\"tables found for deleting/dropping: \\n\" + tables.toString());\r\n\r\n\r\n             //execute delete query for tables\r\n            for (String table: tables) {\r\n\r\n                //if deleteExisting and dropExisting is true\r\n                //skip the deleteExisting query\r\n                //dropExisting will take care of both\r\n                if(deleteExisting && !dropExisting) {\r\n                    String delQ = \"DELETE FROM \" + \"`\" + table + \"`;\";\r\n                    logger.debug(\"adding \" + delQ + \" to batch\");\r\n                    stmt.addBatch(delQ);\r\n                }\r\n\r\n                if(dropExisting) {\r\n                    String dropQ = \"DROP TABLE IF EXISTS \" + \"`\" + table + \"`\";\r\n                    logger.debug(\"adding \" + dropQ + \" to batch\");\r\n                    stmt.addBatch(dropQ);\r\n                }\r\n\r\n            }\r\n\r\n\r\n             List<String> views = allTablesAndViews.getViews();\r\n             //execute delete query for views\r\n            for (String view: views) {\r\n                if(dropExisting) {\r\n                    String dropQ = \"DROP VIEW IF EXISTS \" + \"`\" + view + \"`\";\r\n                    logger.debug(\"adding \" + dropQ + \" to batch\");\r\n                    stmt.addBatch(dropQ);\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        //disable foreign key check\r\n        stmt.addBatch(\"SET FOREIGN_KEY_CHECKS = 0\");\r\n\r\n\r\n        //now process the sql string supplied\r\n        while (sqlString.contains(MysqlBaseService.SQL_START_PATTERN)) {\r\n\r\n            //get the chunk of the first statement to execute\r\n            int startIndex = sqlString.indexOf(MysqlBaseService.SQL_START_PATTERN);\r\n            int endIndex = sqlString.indexOf(MysqlBaseService.SQL_END_PATTERN);\r\n\r\n            String executable = sqlString.substring(startIndex, endIndex).trim();\r\n            logger.debug(\"adding extracted executable SQL chunk to batch : \\n\" + executable);\r\n            stmt.addBatch(executable);\r\n\r\n            //remove the chunk from the whole to reduce it\r\n            sqlString = sqlString.substring(endIndex + 1);\r\n\r\n            //repeat\r\n        }\r\n\r\n\r\n        //add enable foreign key check\r\n        stmt.addBatch(\"SET FOREIGN_KEY_CHECKS = 1\");\r\n\r\n        //now execute the batch\r\n        long[] result = stmt.executeLargeBatch();\r\n\r\n        if(logger.isDebugEnabled())\r\n            logger.debug( result.length + \" queries were executed in batches for provided SQL String with the following result : \\n\" + Arrays.toString(result));\r\n\r\n        stmt.close();\r\n        connection.close();\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * This function will check that required parameters\r\n     * are set.\r\n     * password is excluded here because it's possible to have a mysql database\r\n     * user with no password\r\n     * @return true if the required params are present and valid, false otherwise\r\n     */\r\n    private boolean assertValidParams() {\r\n        return username != null && !this.username.isEmpty() &&\r\n                sqlString != null && !this.sqlString.isEmpty() &&\r\n        ( (database != null && !this.database.isEmpty()) || (jdbcConnString != null && !jdbcConnString.isEmpty()) );\r\n    }\r\n\r\n    /**\r\n     * This function will create a new\r\n     * MysqlImportService instance thereby facilitating\r\n     * a builder pattern\r\n     * @return MysqlImportService\r\n     */\r\n    public static MysqlImportService builder() {\r\n        return new MysqlImportService();\r\n    }\r\n\r\n    public MysqlImportService setDatabase(String database) {\r\n        this.database = database;\r\n        return this;\r\n    }\r\n\r\n    public MysqlImportService setUsername(String username) {\r\n        this.username = username;\r\n        return this;\r\n    }\r\n\r\n    public MysqlImportService setPassword(String password) {\r\n        this.password = password;\r\n        return this;\r\n    }\r\n\r\n    public MysqlImportService setSqlString(String sqlString) {\r\n        this.sqlString = sqlString;\r\n        return this;\r\n    }\r\n\r\n    public MysqlImportService setDeleteExisting(boolean deleteExisting) {\r\n        this.deleteExisting = deleteExisting;\r\n        return this;\r\n    }\r\n\r\n    public MysqlImportService setDropExisting(boolean dropExistingTable) {\r\n        this.dropExisting = dropExistingTable;\r\n        return  this;\r\n    }\r\n\r\n    public MysqlImportService setJdbcDriver(String jdbcDriver) {\r\n        this.jdbcDriver = jdbcDriver;\r\n        return this;\r\n    }\r\n\r\n    public MysqlImportService setJdbcConnString(String jdbcConnString) {\r\n        this.jdbcConnString = jdbcConnString;\r\n        return this;\r\n    }\r\n}", "output_text": "import com.google.cloud.spanner.DatabaseClient;\nimport com.google.cloud.spanner.Spanner;\nimport com.google.cloud.spanner.SpannerOptions;\nimport com.google.cloud.spanner.Statement;\nimport com.google.cloud.spanner.Mutation;\n\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.Arrays;\n\npublic class SpannerImport {\n\n    public static void main(String[] args) {\n        try {\n            importDatabase(\"path/to/sql/dump/file.sql\", \"your-instance-id\", \"your-database-id\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void importDatabase(String filePath, String instanceId, String databaseId) throws Exception {\n        SpannerOptions options = SpannerOptions.newBuilder().build();\n        Spanner spanner = options.getService();\n        DatabaseClient dbClient = spanner.getDatabaseClient(\n                DatabaseId.of(options.getProjectId(), instanceId, databaseId));\n\n        String sql = new String(Files.readAllBytes(Paths.get(filePath)));\n\n        String[] sqlStatements = sql.split(\";\");\n\n        for (String statement : sqlStatements) {\n            statement = statement.trim();\n            if (!statement.isEmpty()) {\n                dbClient.executeDdl(Statement.of(statement));\n                System.out.println(\"Executed: \" + statement);\n            }\n        }\n\n        spanner.close();\n\n        System.out.println(\"Database import completed successfully.\");\n    }\n}\n"}
{"input_text": "convert following Java code from MySQL to Spanner \npublic Integer findCustomerByAgeUsingStoredProcedure(String name) {\n                          final CustomStoredProcedure customStoredProcedure = new  CustomStoredProcedure(jdbcTemplate, \"findCustomerAgeByName\");\n                          final SqlParameter sqlName = new SqlParameter(\"name\", Types.VARCHAR);\n                          final SqlOutParameter outParameter = new SqlOutParameter(\"age\", Types.INTEGER);\n                          final SqlParameter[] sqlParameters = {sqlName,outParameter};\n                          customStoredProcedure.setParameters(sqlParameters);\n                          customStoredProcedure.setJdbcTemplate(jdbcTemplate);\n                          customStoredProcedure.compile();\n                          Map<String,Object> storedProcResult = customStoredProcedure.execute(name, \"age\");\n                          return (Integer)storedProcResult.get(\"age\");\n                    }", "output_text": "Spanner doesn't support and it's equivalent code has to be written from application"}
{"input_text": "convert following Java code from MySQL to Spanner \nDELIMITER $$\n\nCREATE FUNCTION CustomerLevel(C_ID int) \nRETURNS VARCHAR(20)\nDETERMINISTIC\nBEGIN\n    DECLARE customerLevel VARCHAR(20);\n    DECLARE credit float;\n    SELECT sum(O.O_Amount) INTO credit\n    FROM ORDERS AS O\n    WHERE O.C_ID = C_ID\n    GROUP BY O.C_ID;\n    \n\n    IF credit > 25000 THEN\n\t\tSET customerLevel = 'PLATINUM';\n    ELSEIF (credit >= 21000 AND \n\t\t\tcredit <= 25000) THEN\n        SET customerLevel = 'GOLD';\n    ELSEIF credit < 20000 THEN\n        SET customerLevel = 'SILVER';\n    ELSE\n        SET customerLevel = 'BRONZE';\n    END IF;\n\t-- Return the customer level\n\tRETURN (customerLevel);\nEND$$\nDELIMITER ;\n\nSELECT `C_ID`,`First_Name`,`Last_Name`, CustomerLevel(`C_ID`) FROM `Customers`;", "output_text": "Spanner doesn't support function. "}
{"input_text": "convert following Java code from MySQL to Spanner \nCREATE VIEW `Bills` AS\nSELECT C.C_ID, C.First_Name, C.Last_Name, I.Item_ID, I.Item_Name,IC.Brand,IC.Size, O.Quantity, sum(O.O_Amount) AS TOTAL,C.DOP\nFROM Customers AS C JOIN ORDERS AS O ON C.C_ID = O.C_ID JOIN Items as I ON I.Item_ID = O.Item_ID \nJOIN Item_Category AS IC ON I.Item_ID = IC.Item_ID\nGROUP BY O.C_ID,Item_ID\nORDER BY C.DOP ASC;", "output_text": "CREATE VIEW Bills AS\nSELECT \n    C.C_ID, \n    C.First_Name, \n    C.Last_Name, \n    I.Item_ID, \n    I.Item_Name, \n    IC.Brand, \n    IC.Size, \n    O.Quantity, \n    SUM(O.O_Amount) AS TOTAL, \n    C.DOP\nFROM \n    Customers AS C \nJOIN \n    ORDERS AS O ON C.C_ID = O.C_ID \nJOIN \n    Items AS I ON I.Item_ID = O.Item_ID \nJOIN \n    Item_Category AS IC ON I.Item_ID = IC.Item_ID\nGROUP BY \n    C.C_ID, \n    I.Item_ID\nORDER BY \n    C.DOP ASC;\n"}
{"input_text": "convert following Java code from MySQL to Spanner \npublic class DatabaseConnection {\n\n        public static void main(String[] args) {\n                try {\n                        connectToDB();\n                }catch (Exception e){\n                        e.printStackTrace();\n                }\n        }\n        \n\n        /**\n         * Connect to MySQL Database\n         * @throws SQLException\n         */\n        private static void connectToDB() throws SQLException{\n                \n                // 1. Get the Connection instance using the DriverManager.getConnection() method \n                //    with your MySQL Database Credentails\n    \n                Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/tutorialsdojo\",\n                                \"tutorialsdojo\", \"P@sSword123\");\n                \n                System.out.println(\"LOG: Connection Established!\");\n  \n                }\n        }", "output_text": "import com.google.cloud.spanner.DatabaseClient;\nimport com.google.cloud.spanner.Spanner;\nimport com.google.cloud.spanner.SpannerOptions;\nimport com.google.cloud.spanner.Statement;\nimport com.google.cloud.spanner.ResultSet;\n\npublic class DatabaseConnection {\n\n    public static void main(String[] args) {\n        try {\n            connectToDB();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n\n    private static void connectToDB() {\n        // 1. Initialize Spanner client\n        SpannerOptions options = SpannerOptions.newBuilder().build();\n        Spanner spanner = options.getService();\n\n        // 2. Get a database client\n        String instanceId = \"tutorialsdojo\";\n        String databaseId = \"tutorialsdojo\";\n        DatabaseClient dbClient = spanner.getDatabaseClient(\n                DatabaseId.of(options.getProjectId(), instanceId, databaseId));\n\n        System.out.println(\"LOG: Connection Established!\");\n\n        // Example query to verify the connection\n        try (ResultSet resultSet = dbClient.singleUse().executeQuery(Statement.of(\"SELECT 1\"))) {\n            while (resultSet.next()) {\n                System.out.println(\"Query Result: \" + resultSet.getLong(0));\n            }\n        }\n\n        // Close the spanner client\n        spanner.close();\n    }\n}\n"}
{"input_text": "convert following Java code from MySQL to Spanner \nCREATE TABLE IF NOT EXISTS event_journal (\n    ordering SERIAL,\n    deleted BOOLEAN DEFAULT false NOT NULL,\n    persistence_id VARCHAR(255) NOT NULL,\n    sequence_number BIGINT NOT NULL,\n    writer TEXT NOT NULL,\n    write_timestamp BIGINT NOT NULL,\n    adapter_manifest TEXT NOT NULL,\n    event_payload BLOB NOT NULL,\n    event_ser_id INTEGER NOT NULL,\n    event_ser_manifest TEXT NOT NULL,\n    meta_payload BLOB,\n    meta_ser_id INTEGER,meta_ser_manifest TEXT,\n    PRIMARY KEY(persistence_id,sequence_number)\n);\n\nCREATE UNIQUE INDEX event_journal_ordering_idx ON event_journal(ordering);\n\nCREATE TABLE IF NOT EXISTS event_tag (\n    event_id BIGINT UNSIGNED,\n    persistence_id VARCHAR(255),\n    sequence_number BIGINT,\n    tag VARCHAR(255) NOT NULL,\n    PRIMARY KEY(persistence_id, sequence_number, tag),\n    FOREIGN KEY (persistence_id, sequence_number)\n        REFERENCES event_journal(persistence_id, sequence_number)\n        ON DELETE CASCADE\n    );\n\nCREATE TABLE IF NOT EXISTS snapshot (\n    persistence_id VARCHAR(255) NOT NULL,\n    sequence_number BIGINT NOT NULL,\n    created BIGINT NOT NULL,\n    snapshot_ser_id INTEGER NOT NULL,\n    snapshot_ser_manifest TEXT NOT NULL,\n    snapshot_payload BLOB NOT NULL,\n    meta_ser_id INTEGER,\n    meta_ser_manifest TEXT,\n    meta_payload BLOB,\n  PRIMARY KEY (persistence_id, sequence_number));", "output_text": "CREATE TABLE event_journal (\n    ordering INT64 NOT NULL,\n    deleted BOOL DEFAULT false NOT NULL,\n    persistence_id STRING(255) NOT NULL,\n    sequence_number INT64 NOT NULL,\n    writer STRING(MAX) NOT NULL,\n    write_timestamp INT64 NOT NULL,\n    adapter_manifest STRING(MAX) NOT NULL,\n    event_payload BYTES(MAX) NOT NULL,\n    event_ser_id INT64 NOT NULL,\n    event_ser_manifest STRING(MAX) NOT NULL,\n    meta_payload BYTES(MAX),\n    meta_ser_id INT64,\n    meta_ser_manifest STRING(MAX),\n    PRIMARY KEY (persistence_id, sequence_number)\n);\n\nCREATE UNIQUE INDEX event_journal_ordering_idx ON event_journal(ordering);\n\nCREATE TABLE event_tag (\n    event_id INT64 NOT NULL,\n    persistence_id STRING(255) NOT NULL,\n    sequence_number INT64 NOT NULL,\n    tag STRING(255) NOT NULL,\n    PRIMARY KEY (persistence_id, sequence_number, tag),\n    FOREIGN KEY (persistence_id, sequence_number)\n        REFERENCES event_journal (persistence_id, sequence_number)\n);\n\nCREATE TABLE snapshot (\n    persistence_id STRING(255) NOT NULL,\n    sequence_number INT64 NOT NULL,\n    created INT64 NOT NULL,\n    snapshot_ser_id INT64 NOT NULL,\n    snapshot_ser_manifest STRING(MAX) NOT NULL,\n    snapshot_payload BYTES(MAX) NOT NULL,\n    meta_ser_id INT64,\n    meta_ser_manifest STRING(MAX),\n    meta_payload BYTES(MAX),\n    PRIMARY KEY (persistence_id, sequence_number)\n);"}
{"input_text": "convert following Java code from MySQL to Spanner \npackage com.shashi.utility;\n\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.ResourceBundle;\n\npublic class DBUtil {\n        private static Connection conn;\n\n        public DBUtil() {\n        }\n\n        public static Connection provideConnection() {\n\n                try {\n                        if (conn == null || conn.isClosed()) {\n                                ResourceBundle rb = ResourceBundle.getBundle(\"application\");\n                                String connectionString = rb.getString(\"db.connectionString\");\n                                String driverName = rb.getString(\"db.driverName\");\n                                String username = rb.getString(\"db.username\");\n                                String password = rb.getString(\"db.password\");\n                                try {\n                                        Class.forName(driverName);\n                                } catch (ClassNotFoundException e) {\n                                        e.printStackTrace();\n                                }\n                                conn = DriverManager.getConnection(connectionString, username, password);\n\n                        }\n                } catch (SQLException e) {\n                        // TODO Auto-generated catch block\n                        e.printStackTrace();\n                }\n\n                return conn;\n        }\n\n        public static void closeConnection(Connection con) {\n                /*\n                 * try { if (con != null && !con.isClosed()) {\n                 * \n                 * con.close(); } } catch (SQLException e) { // TODO Auto-generated catch block\n                 * e.printStackTrace(); }\n                 */\n        }\n\n        public static void closeConnection(ResultSet rs) {\n                try {\n                        if (rs != null && !rs.isClosed()) {\n                                try {\n                                        rs.close();\n                                } catch (SQLException e) {\n                                        // TODO Auto-generated catch block\n                                        e.printStackTrace();\n                                }\n                        }\n                } catch (SQLException e) {\n                        // TODO Auto-generated catch block\n                        e.printStackTrace();\n                }\n        }\n\n        public static void closeConnection(PreparedStatement ps) {\n                try {\n                        if (ps != null && !ps.isClosed()) {\n                                try {\n                                        ps.close();\n                                } catch (SQLException e) {\n                                        // TODO Auto-generated catch block\n                                        e.printStackTrace();\n                                }\n                        }\n                } catch (SQLException e) {\n                        // TODO Auto-generated catch block\n                        e.printStackTrace();\n                }\n        }\n}\n", "output_text": "package com.shashi.utility;\n\nimport com.google.api.gax.core.FixedCredentialsProvider;\nimport com.google.auth.oauth2.GoogleCredentials;\nimport com.google.cloud.spanner.DatabaseClient;\nimport com.google.cloud.spanner.DatabaseId;\nimport com.google.cloud.spanner.Spanner;\nimport com.google.cloud.spanner.SpannerOptions;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.sql.SQLException;\nimport java.util.ResourceBundle;\n\npublic class DBUtil {\n\n    private static Spanner spanner;\n    private static DatabaseClient dbClient;\n\n    private DBUtil() {\n        // Private constructor to prevent instantiation\n    }\n\n    public static DatabaseClient provideDatabaseClient() {\n        if (dbClient == null || spanner == null || spanner.isClosed()) {\n            try {\n                initializeSpanner();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return dbClient;\n    }\n\n    private static void initializeSpanner() throws IOException {\n        ResourceBundle rb = ResourceBundle.getBundle(\"application\");\n        String projectId = rb.getString(\"spanner.projectId\");\n        String instanceId = rb.getString(\"spanner.instanceId\");\n        String databaseId = rb.getString(\"spanner.databaseId\");\n\n        // Load credentials from JSON file\n        GoogleCredentials credentials = GoogleCredentials.fromStream(\n                new FileInputStream(rb.getString(\"spanner.credentialsFile\")));\n        SpannerOptions options = SpannerOptions.newBuilder()\n                .setProjectId(projectId)\n                .setCredentials(credentials)\n                .build();\n\n        // Initialize Spanner\n        spanner = options.getService();\n        DatabaseId dbId = DatabaseId.of(projectId, instanceId, databaseId);\n        dbClient = spanner.getDatabaseClient(dbId);\n    }\n\n    public static void closeSpanner() {\n        if (spanner != null && !spanner.isClosed()) {\n            spanner.close();\n        }\n    }\n}\n"}
{"input_text": "convert following Java code from MySQL to Spanner \npackage com.arifng.dbmultitenancy;\r\n\r\nimport org.springframework.boot.builder.SpringApplicationBuilder;\r\nimport org.springframework.boot.web.servlet.support.SpringBootServletInitializer;\r\n\r\npublic class ServletInitializer extends SpringBootServletInitializer {\r\n\r\n\t@Override\r\n\tprotected SpringApplicationBuilder configure(SpringApplicationBuilder application) {\r\n\t\treturn application.sources(SpringJpaHibernateMySqlMultitenancyApplication.class);\r\n\t}\r\n\r\n}\r\n", "output_text": "package com.arifng.dbmultitenancy;\r\n\r\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\r\nimport org.springframework.boot.builder.SpringApplicationBuilder;\r\n\r\n@SpringBootApplication\r\npublic class ServletInitializer {\r\n\r\n    public static void main(String[] args) {\r\n        SpringApplicationBuilder builder = new SpringApplicationBuilder(ServletInitializer.class);\r\n        builder.headless(false);\r\n        builder.run(args);\r\n    }\r\n}\r"}
{"input_text": "convert following Java code from MySQL to Spanner \npackage com.arifng.dbmultitenancy;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class SpringJpaHibernateMySqlMultitenancyApplication {\n\n        public static void main(String[] args) {\n                SpringApplication.run(SpringJpaHibernateMySqlMultitenancyApplication.class, args);\n        }\n\n}\n", "output_text": "package com.arifng.dbmultitenancy;\r\n\r\nimport org.springframework.boot.SpringApplication;\r\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\r\n\r\n@SpringBootApplication\r\npublic class SpringJpaSpannerMultitenancyApplication {\r\n\r\n    public static void main(String[] args) {\r\n        SpringApplication.run(SpringJpaSpannerMultitenancyApplication.class, args);\r\n    }\r\n\r\n}\r"}
{"input_text": "convert following Java code from MySQL to Spanner \npackage com.arifng.dbmultitenancy.repoconfig;\r\n\r\nimport com.arifng.dbmultitenancy.model.BaseEntity;\r\nimport org.hibernate.cfg.AvailableSettings;\r\nimport org.hibernate.engine.jdbc.connections.spi.MultiTenantConnectionProvider;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Configuration;\r\nimport org.springframework.context.annotation.DependsOn;\r\nimport org.springframework.context.annotation.aspectj.EnableSpringConfigured;\r\nimport org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor;\r\nimport org.springframework.data.jpa.repository.config.EnableJpaRepositories;\r\nimport org.springframework.orm.jpa.JpaTransactionManager;\r\nimport org.springframework.orm.jpa.JpaVendorAdapter;\r\nimport org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;\r\nimport org.springframework.orm.jpa.vendor.HibernateJpaDialect;\r\nimport org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter;\r\nimport org.springframework.transaction.PlatformTransactionManager;\r\nimport org.springframework.transaction.annotation.EnableTransactionManagement;\r\n\r\nimport javax.persistence.EntityManagerFactory;\r\nimport java.util.Properties;\r\n\r\n/**\r\n * Created by rana on 30/6/19.\r\n */\r\n@Configuration\r\n@EnableJpaRepositories(basePackages = {\"com.arifng.dbmultitenancy.repository\"})\r\n@EnableSpringConfigured\r\n@EnableTransactionManagement\r\npublic class RepositoryConfiguration {\r\n    @Bean\r\n    public DatabaseConfiguration databaseConfiguration() {\r\n        return new DatabaseConfiguration();\r\n    }\r\n\r\n    @Bean\r\n    @DependsOn(value = \"flywayMigrationInitializer\")\r\n    public LocalContainerEntityManagerFactoryBean entityManagerFactory() {\r\n        LocalContainerEntityManagerFactoryBean entityManagerFactoryBean = new LocalContainerEntityManagerFactoryBean();\r\n        entityManagerFactoryBean.setPackagesToScan(BaseEntity.class.getPackage().getName());\r\n        entityManagerFactoryBean.setDataSource(routingDataSource().getDefaultDataSource());\r\n        entityManagerFactoryBean.setJpaVendorAdapter(hibernateJpaVendorAdapter());\r\n        entityManagerFactoryBean.setJpaProperties(hibernateProperties());\r\n        entityManagerFactoryBean.setJpaDialect(new HibernateJpaDialect());\r\n        return entityManagerFactoryBean;\r\n    }\r\n\r\n    @Bean\r\n    public RoutingDataSource routingDataSource() {\r\n        RoutingDataSource routingDataSource = new RoutingDataSource();\r\n        routingDataSource.initDataSources(databaseConfiguration());\r\n        return routingDataSource;\r\n    }\r\n\r\n    @Bean\r\n    public JpaVendorAdapter hibernateJpaVendorAdapter() {\r\n        HibernateJpaVendorAdapter jpaVendorAdapter = new HibernateJpaVendorAdapter();\r\n        jpaVendorAdapter.setDatabase(org.springframework.orm.jpa.vendor.Database.MYSQL);\r\n        return jpaVendorAdapter;\r\n    }\r\n\r\n    @Bean\r\n    public MultiTenantConnectionProvider multiTenantConnectionProvider() {\r\n        return new MultitenantConnectionProvider();\r\n    }\r\n\r\n    @Bean\r\n    public PlatformTransactionManager transactionManager(EntityManagerFactory emf) {\r\n        JpaTransactionManager transactionManager = new JpaTransactionManager();\r\n        transactionManager.setEntityManagerFactory(emf);\r\n        return transactionManager;\r\n    }\r\n\r\n    @Bean\r\n    public PersistenceExceptionTranslationPostProcessor exceptionTranslation() {\r\n        return new PersistenceExceptionTranslationPostProcessor();\r\n    }\r\n\r\n    @Bean(initMethod = \"migrate\")\r\n    public FlywayMigrationInitializer flywayMigrationInitializer() {\r\n        return new FlywayMigrationInitializer();\r\n    }\r\n\r\n    private Properties hibernateProperties() {\r\n        Properties properties = new Properties();\r\n        properties.setProperty(AvailableSettings.HBM2DDL_AUTO, \"none\");\r\n        properties.setProperty(AvailableSettings.DIALECT, \"org.hibernate.dialect.MySQL57InnoDBDialect\");\r\n        properties.setProperty(AvailableSettings.IGNORE_EXPLICIT_DISCRIMINATOR_COLUMNS_FOR_JOINED_SUBCLASS, \"true\");\r\n        properties.setProperty(\"hibernate.jpa.compliance.transaction\", \"true\");\r\n        properties.setProperty(\"hibernate.jpa.compliance.query\", \"true\");\r\n        properties.setProperty(\"hibernate.jpa.compliance.list\", \"true\");\r\n        properties.setProperty(AvailableSettings.JPA_ID_GENERATOR_GLOBAL_SCOPE_COMPLIANCE, \"true\");\r\n        properties.setProperty(AvailableSettings.JPAQL_STRICT_COMPLIANCE, \"true\");\r\n        properties.setProperty(AvailableSettings.ENABLE_LAZY_LOAD_NO_TRANS, \"true\");\r\n        properties.setProperty(AvailableSettings.SHOW_SQL, \"false\");\r\n        properties.setProperty(AvailableSettings.FORMAT_SQL, \"false\");\r\n        properties.setProperty(AvailableSettings.CONNECTION_PROVIDER_DISABLES_AUTOCOMMIT, \"true\");\r\n        properties.setProperty(AvailableSettings.MAX_FETCH_DEPTH, \"4\");\r\n        properties.setProperty(AvailableSettings.DEFAULT_BATCH_FETCH_SIZE, \"16\");\r\n        properties.setProperty(AvailableSettings.ORDER_UPDATES, \"true\");\r\n\r\n        properties.setProperty(AvailableSettings.MULTI_TENANT, \"DATABASE\");\r\n        properties.setProperty(AvailableSettings.MULTI_TENANT_IDENTIFIER_RESOLVER,\r\n                TenantIdentifierResolver.class.getName());\r\n\r\n        properties.put(AvailableSettings.MULTI_TENANT_CONNECTION_PROVIDER, multiTenantConnectionProvider());\r\n        return properties;\r\n    }\r\n}\r\n", "output_text": "package com.arifng.dbmultitenancy.repoconfig;\r\n\r\nimport com.google.cloud.spanner.hibernate.SpannerHibernateDialect;\r\nimport com.google.cloud.spanner.hibernate.SpannerMultiTenantConnectionProvider;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Configuration;\r\nimport org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor;\r\nimport org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;\r\nimport org.springframework.orm.jpa.vendor.HibernateJpaDialect;\r\nimport org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter;\r\nimport org.springframework.transaction.PlatformTransactionManager;\r\nimport org.springframework.transaction.annotation.EnableTransactionManagement;\r\n\r\nimport javax.persistence.EntityManagerFactory;\r\nimport java.util.Properties;\r\n\r\n@Configuration\r\n@EnableTransactionManagement\r\npublic class RepositoryConfiguration {\r\n\r\n    @Bean\r\n    public LocalContainerEntityManagerFactoryBean entityManagerFactory() {\r\n        LocalContainerEntityManagerFactoryBean entityManagerFactoryBean = new LocalContainerEntityManagerFactoryBean();\r\n        entityManagerFactoryBean.setPersistenceUnitName(\"spannerPersistenceUnit\");\r\n        entityManagerFactoryBean.setJpaVendorAdapter(new HibernateJpaVendorAdapter());\r\n        entityManagerFactoryBean.setJpaProperties(hibernateProperties());\r\n        entityManagerFactoryBean.setPackagesToScan(\"com.arifng.dbmultitenancy.model\"); // Adjust this to your entity package\r\n        entityManagerFactoryBean.setJpaDialect(new HibernateJpaDialect());\r\n        return entityManagerFactoryBean;\r\n    }\r\n\r\n    @Bean\r\n    public SpannerMultiTenantConnectionProvider multiTenantConnectionProvider() {\r\n        return new SpannerMultiTenantConnectionProvider();\r\n    }\r\n\r\n    @Bean\r\n    public PlatformTransactionManager transactionManager(EntityManagerFactory emf) {\r\n        return new JpaTransactionManager(emf);\r\n    }\r\n\r\n    @Bean\r\n    public PersistenceExceptionTranslationPostProcessor exceptionTranslation() {\r\n        return new PersistenceExceptionTranslationPostProcessor();\r\n    }\r\n\r\n    private Properties hibernateProperties() {\r\n        Properties properties = new Properties();\r\n        properties.setProperty(\"hibernate.dialect\", SpannerHibernateDialect.class.getName());\r\n        properties.setProperty(\"hibernate.show_sql\", \"false\"); // Spanner does not support \"SHOW SQL\" property\r\n        properties.setProperty(\"hibernate.format_sql\", \"false\"); // Spanner does not support \"FORMAT SQL\" property\r\n\r\n        // Spanner-specific properties\r\n        properties.setProperty(\"hibernate.multiTenancy\", \"DATABASE\"); // Set to \"DATABASE\" for Spanner\r\n        properties.setProperty(\"hibernate.multi_tenant_connection_provider\", multiTenantConnectionProvider().getClass().getName());\r\n        properties.setProperty(\"hibernate.multiTenancy.identifier_resolver\", TenantIdentifierResolver.class.getName());\r\n\r\n        // Additional properties\r\n        // Modify these as per Spanner-specific requirements or leave them out if not applicable\r\n\r\n        return properties;\r\n    }\r\n}\r"}
{"input_text": "convert following Java code from MySQL to Spanner \npackage com.arifng.dbmultitenancy.repoconfig;\r\n\r\nimport com.arifng.dbmultitenancy.model.Tenant;\r\nimport com.zaxxer.hikari.HikariConfig;\r\nimport com.zaxxer.hikari.HikariDataSource;\r\nimport org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;\r\n\r\nimport javax.sql.DataSource;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\n\r\n/**\r\n * Created by rana on 30/6/19.\r\n */\r\npublic class RoutingDataSource extends AbstractRoutingDataSource {\r\n    private static final Map<Object, Object> dataSourceMap = new HashMap<>();\r\n\r\n    @Override\r\n    protected Object determineCurrentLookupKey() {\r\n        return TenantContext.getTenant();\r\n    }\r\n\r\n    void initDataSources(DatabaseConfiguration configuration) {\r\n        for (Tenant tenant : Tenant.values()) {\r\n            dataSourceMap.put(tenant, new HikariDataSource(hikariConfig(tenant, configuration)));\r\n        }\r\n        setDefaultTargetDataSource(getDefaultDataSource());\r\n        setTargetDataSources(dataSourceMap);\r\n    }\r\n\r\n    DataSource getDataSourceByTenant(Tenant tenant) {\r\n        return (DataSource) dataSourceMap.get(tenant);\r\n    }\r\n\r\n    DataSource getDefaultDataSource() {\r\n        return getDataSourceByTenant(Tenant.DEFAULT);\r\n    }\r\n\r\n    private HikariConfig hikariConfig(Tenant tenant,\r\n                                      DatabaseConfiguration configuration) {\r\n        HikariConfig hikariConfig = new HikariConfig();\r\n        hikariConfig.setDriverClassName(\"com.mysql.cj.jdbc.Driver\");\r\n        hikariConfig.setJdbcUrl(configuration.getUrl().replace(\"tenantName\", tenant.getName()));\r\n        hikariConfig.setUsername(configuration.getUser());\r\n        hikariConfig.setPassword(configuration.getPassword());\r\n        hikariConfig.setAutoCommit(Boolean.FALSE);\r\n        hikariConfig.addDataSourceProperty(\"dataSource.cachePrepStmts\", Boolean.TRUE);\r\n        hikariConfig.addDataSourceProperty(\"dataSource.prepStmtCacheSize\", 250);\r\n        hikariConfig.addDataSourceProperty(\"dataSource.prepStmtCacheSqlLimit\", 2048);\r\n        hikariConfig.addDataSourceProperty(\"dataSource.useServerPrepStmts\", Boolean.TRUE);\r\n        hikariConfig.addDataSourceProperty(\"dataSource.useLocalSessionState\", Boolean.TRUE);\r\n        hikariConfig.addDataSourceProperty(\"dataSource.rewriteBatchedStatements\", Boolean.TRUE);\r\n        hikariConfig.addDataSourceProperty(\"dataSource.cacheResultSetMetadata\", Boolean.TRUE);\r\n        hikariConfig.addDataSourceProperty(\"dataSource.cacheServerConfiguration\", Boolean.TRUE);\r\n        hikariConfig.addDataSourceProperty(\"dataSource.maintainTimeStats\", Boolean.FALSE);\r\n        return hikariConfig;\r\n    }\r\n}\r\n", "output_text": "package com.arifng.dbmultitenancy.repoconfig;\r\n\r\nimport com.arifng.dbmultitenancy.model.Tenant;\r\nimport com.google.cloud.spanner.SpannerOptions;\r\nimport com.google.cloud.spanner.jdbc.CloudSpannerDriver;\r\nimport com.google.cloud.spanner.jdbc.ConnectionOptions;\r\nimport org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;\r\n\r\nimport javax.sql.DataSource;\r\nimport java.sql.Connection;\r\nimport java.sql.DriverManager;\r\nimport java.sql.SQLException;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\nimport java.util.Properties;\r\n\r\npublic class RoutingDataSource extends AbstractRoutingDataSource {\r\n\r\n    private static final Map<Object, DataSource> dataSourceMap = new HashMap<>();\r\n\r\n    @Override\r\n    protected Object determineCurrentLookupKey() {\r\n        return TenantContext.getTenant();\r\n    }\r\n\r\n    void initDataSources(DatabaseConfiguration configuration) {\r\n        for (Tenant tenant : Tenant.values()) {\r\n            dataSourceMap.put(tenant, createSpannerDataSource(tenant, configuration));\r\n        }\r\n        setDefaultTargetDataSource(getDefaultDataSource());\r\n        setTargetDataSources(dataSourceMap);\r\n    }\r\n\r\n    DataSource getDataSourceByTenant(Tenant tenant) {\r\n        return dataSourceMap.get(tenant);\r\n    }\r\n\r\n    DataSource getDefaultDataSource() {\r\n        return getDataSourceByTenant(Tenant.DEFAULT);\r\n    }\r\n\r\n    private DataSource createSpannerDataSource(Tenant tenant, DatabaseConfiguration configuration) {\r\n        try {\r\n            // Create Spanner options\r\n            SpannerOptions options = SpannerOptions.newBuilder().build();\r\n\r\n            // Build JDBC URL for Spanner\r\n            String jdbcUrl = String.format(\"jdbc:cloudspanner://%s/projects/%s/instances/%s/databases/%s\",\r\n                    configuration.getSpannerEndpoint(), configuration.getProjectId(),\r\n                    configuration.getInstanceId(), tenant.getName());\r\n\r\n            // Create connection properties\r\n            Properties properties = new Properties();\r\n            properties.setProperty(ConnectionOptions.MIN_SESSIONS, \"100\");\r\n            properties.setProperty(ConnectionOptions.MAX_SESSIONS, \"1000\");\r\n\r\n            // Create and return DataSource using CloudSpannerDriver\r\n            DriverManager.registerDriver(new CloudSpannerDriver());\r\n            return new CloudSpannerDriver().connect(jdbcUrl, properties);\r\n        } catch (SQLException e) {\r\n            throw new RuntimeException(\"Failed to create Spanner DataSource for tenant: \" + tenant.getName(), e);\r\n        }\r\n    }\r\n}\r"}
{"input_text": "convert following Java code from MySQL to Spanner \npackage com.arifng.dbmultitenancy;\r\n\r\nimport org.junit.Test;\r\nimport org.junit.runner.RunWith;\r\nimport org.springframework.boot.test.context.SpringBootTest;\r\nimport org.springframework.test.context.junit4.SpringRunner;\r\n\r\n@RunWith(SpringRunner.class)\r\n@SpringBootTest\r\npublic class SpringJpaHibernateMySqlMultitenancyApplicationTests {\r\n\r\n\t@Test\r\n\tpublic void contextLoads() {\r\n\t}\r\n\r\n}\r\n", "output_text": "package com.arifng.dbmultitenancy;\r\n\r\nimport org.junit.jupiter.api.Test;\r\nimport org.junit.jupiter.api.extension.ExtendWith;\r\nimport org.springframework.boot.test.context.SpringBootTest;\r\nimport org.springframework.test.context.TestPropertySource;\r\nimport org.springframework.test.context.junit.jupiter.SpringExtension;\r\n\r\n@ExtendWith(SpringExtension.class)\r\n@SpringBootTest\r\n@TestPropertySource(locations = \"classpath:application-test.properties\")\r\npublic class SpannerTestConfiguration {\r\n\r\n    @Test\r\n    public void contextLoads() {\r\n    }\r\n\r\n}\r"}
{"input_text": "convert following Java code from MySQL to Spanner \npackage com.kenshoo.jooq;\r\n\r\nimport com.mysql.jdbc.ConnectionImpl;\r\nimport org.jooq.DSLContext;\r\nimport org.jooq.SQLDialect;\r\nimport org.jooq.impl.DSL;\r\nimport org.jooq.impl.DefaultConfiguration;\r\nimport org.jooq.impl.ThreadLocalTransactionProvider;\r\nimport org.jooq.lambda.Unchecked;\r\nimport java.sql.SQLException;\r\nimport java.util.Properties;\r\n\r\nimport static java.lang.Integer.parseInt;\r\n\r\npublic class TestJooqConfig {\r\n\r\n    private static ClosableConnectionProvider previousConnectionProvider;\r\n\r\n    public static DSLContext create() {\r\n        return create(alwaysAllocatingNewConnections());\r\n    }\r\n\r\n    public static DSLContext create(ClosableConnectionProvider connectionProvider) {\r\n        closePreviousConnectionProvider();\r\n        previousConnectionProvider = connectionProvider;\r\n        DefaultConfiguration conf = new DefaultConfiguration();\r\n        conf.setSQLDialect(SQLDialect.MYSQL);\r\n        // Don't need to do this: conf.setConnectionProvider(connectionProvider);\r\n        conf.setTransactionProvider(new ThreadLocalTransactionProvider(connectionProvider));\r\n        return DSL.using(conf);\r\n    }\r\n\r\n    public static AlwaysAllocateNewConnection alwaysAllocatingNewConnections() {\r\n        Properties props = readProperties(\"/database.properties\");\r\n        return new AlwaysAllocateNewConnection(() -> connection(props));\r\n    }\r\n\r\n    private static void closePreviousConnectionProvider() {\r\n        if (previousConnectionProvider != null) {\r\n            Unchecked.runnable(previousConnectionProvider::close).run();\r\n        }\r\n    }\r\n\r\n    private static ConnectionImpl connection(Properties props)  {\r\n        try {\r\n            return new ConnectionImpl(props.getProperty(\"server\"), parseInt(props.getProperty(\"port\")), props, props.getProperty(\"database\"), null);\r\n        } catch (SQLException e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n\r\n    private static Properties readProperties(String resourceName) {\r\n        try {\r\n            Properties props = new Properties();\r\n            props.load(TestJooqConfig.class.getResourceAsStream(resourceName));\r\n            return props;\r\n        } catch (Exception e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n}\r\n", "output_text": "package com.kenshoo.jooq;\n\nimport com.google.api.gax.core.FixedCredentialsProvider;\nimport com.google.auth.oauth2.GoogleCredentials;\nimport com.google.cloud.spanner.DatabaseClient;\nimport com.google.cloud.spanner.Spanner;\nimport com.google.cloud.spanner.SpannerOptions;\nimport com.google.cloud.spanner.Statement;\nimport com.google.cloud.spanner.TransactionContext;\nimport com.google.cloud.spanner.TransactionRunner;\nimport org.jooq.DSLContext;\nimport org.jooq.SQLDialect;\nimport org.jooq.impl.DSL;\nimport org.jooq.impl.DefaultConfiguration;\nimport org.jooq.impl.ThreadLocalTransactionProvider;\nimport org.jooq.lambda.Unchecked;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.util.Properties;\nimport java.util.concurrent.Callable;\n\nimport static java.lang.Integer.parseInt;\n\npublic class TestSpannerConfig {\n\n    private static DatabaseClient dbClient;\n    private static ClosableSpannerProvider previousSpannerProvider;\n\n    public static DSLContext create() {\n        return create(alwaysAllocatingNewSpanner());\n    }\n\n    public static DSLContext create(ClosableSpannerProvider spannerProvider) {\n        closePreviousSpannerProvider();\n        previousSpannerProvider = spannerProvider;\n        DefaultConfiguration conf = new DefaultConfiguration();\n        conf.setSQLDialect(SQLDialect.DEFAULT); // Spanner does not have a specific SQLDialect\n        conf.setTransactionProvider(new ThreadLocalTransactionProvider(spannerProvider));\n        return DSL.using(conf);\n    }\n\n    public static AlwaysAllocateNewSpanner alwaysAllocatingNewSpanner() {\n        Properties props = readProperties(\"/spanner.properties\");\n        return new AlwaysAllocateNewSpanner(() -> spanner(props));\n    }\n\n    private static void closePreviousSpannerProvider() {\n        if (previousSpannerProvider != null) {\n            Unchecked.runnable(previousSpannerProvider::close).run();\n        }\n    }\n\n    private static DatabaseClient spanner(Properties props) {\n        try {\n            GoogleCredentials credentials = GoogleCredentials.fromStream(\n                    new FileInputStream(props.getProperty(\"credentialsPath\"))); // Path to your JSON credentials file\n            SpannerOptions options = SpannerOptions.newBuilder()\n                    .setCredentialsProvider(FixedCredentialsProvider.create(credentials))\n                    .setProjectId(props.getProperty(\"projectId\"))\n                    .build();\n            Spanner spanner = options.getService();\n            dbClient = spanner.getDatabaseClient(\n                    props.getProperty(\"instanceId\"), props.getProperty(\"databaseId\"));\n            return dbClient;\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private static Properties readProperties(String resourceName) {\n        try {\n            Properties props = new Properties();\n            props.load(TestSpannerConfig.class.getResourceAsStream(resourceName));\n            return props;\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    // Example method to execute a query using JOOQ and Spanner\n    public static void executeQuery(DSLContext dslContext) {\n        dslContext.transaction(configuration -> {\n            TransactionContext txContext = DSL.using(configuration).transactionContext();\n            TransactionRunner runner = txContext.runner();\n\n            Callable<Void> callable = () -> {\n                // Example query using JOOQ DSLContext\n                dslContext.fetchOne(\"SELECT 1\");\n\n                return null;\n            };\n\n            runner.run(callable);\n        });\n    }\n}\n"}
{"input_text": "convert following Java code from MySQL to Spanner \npackage com.kenshoo.pl.entity;\n\nimport com.kenshoo.pl.entity.mysql.MySqlDeadlockDetector;\nimport com.kenshoo.pl.entity.spi.ThrowingAction;\nimport com.mysql.jdbc.exceptions.jdbc4.MySQLTransactionRollbackException;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.sql.SQLException;\n\nimport static org.mockito.Mockito.doAnswer;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.times;\nimport static org.mockito.Mockito.verify;\n\npublic class DeadlockRetryerTest {\n\n    private DeadlockRetryer classUnderTest;\n\n    private ThrowingAction updateToDB = mock(ThrowingAction.class);\n\n    @Before\n    public void setUp() {\n        classUnderTest = new DeadlockRetryer(new MySqlDeadlockDetector(), () -> false)\n                .setFirstSleepBetweenRetriesMillis(1)\n                .setIncrementSleepBetweenRetriesMillis(1)\n                .setMaxDeadlockRetries(5);\n    }\n\n    @Test\n    public void update_Should_succeed_in_case_of_no_exceptions() throws Exception {\n        classUnderTest.run(updateToDB);\n        verify(updateToDB, times(1)).run();\n    }\n\n    @Test\n    public void update_should_retry_when_SQL_exception_contains_lock_wait_timeout_exceeded() throws Exception {\n        doAnswer(invocation -> {\n            throw new SQLException(\"test lock wait timeout exceeded test\");\n        })\n                .doAnswer(invocation -> {\n                    throw new SQLException(\"test lock wait timeout exceeded test\");\n                })\n                .doAnswer(invocation -> {\n                    throw new SQLException(\"test lock wait timeout exceeded test\");\n                })\n                .doNothing()\n                .when(updateToDB).run();\n\n        classUnderTest.run(updateToDB);\n        verify(updateToDB, times(4)).run();\n    }\n\n    @Test\n    public void update_should_retry_when_SQL_exception_contains_word_deadlock() throws Exception {\n        doAnswer(invocation -> {\n            throw new MySQLTransactionRollbackException(\"test 111DeAdLock222 test\");\n        })\n                .doAnswer(invocation -> {\n                    throw new MySQLTransactionRollbackException(\"test 111DeAdLock222 test\");\n                })\n                .doAnswer(invocation -> {\n                    throw new MySQLTransactionRollbackException(\"test 111DeAdLock222 test\");\n                })\n                .doNothing()\n                .when(updateToDB).run();\n\n        classUnderTest.run(updateToDB);\n        verify(updateToDB, times(4)).run();\n    }\n\n    @Test\n    public void update_should_not_retry_on_non_SQL_exception_types() throws Exception {\n        doAnswer(invocation -> {\n            throw new RuntimeException(\"test 111DeAdLock222 test\");\n        })\n                .doAnswer(invocation -> {\n                    throw new RuntimeException(\"test 111DeAdLock222 test\");\n                })\n                .doAnswer(invocation -> {\n                    throw new RuntimeException(\"test 111DeAdLock222 test\");\n                })\n                .doNothing()\n                .when(updateToDB).run();\n        try {\n            classUnderTest.run(updateToDB);\n        } catch (RuntimeException e) {\n            verify(updateToDB, times(1)).run();\n        }\n    }\n\n    @Test\n    public void update_should_not_retry_when_SQL_exception_message_is_not_recognized() throws Exception {\n        doAnswer(invocation -> {\n            throw new SQLException(\"unrecognized message\");\n        })\n                .doAnswer(invocation -> {\n                    throw new SQLException(\"unrecognized message\");\n                })\n                .doAnswer(invocation -> {\n                    throw new SQLException(\"unrecognized message\");\n                })\n                .doNothing()\n                .when(updateToDB).run();\n        try {\n            classUnderTest.run(updateToDB);\n        } catch (RuntimeException e) {\n            verify(updateToDB, times(1)).run();\n        }\n    }\n\n    @Test\n    public void update_should_stop_retrying_after_max_number_of_attempts() throws Exception {\n        doAnswer(invocation -> {\n            throw new SQLException(\"bla_bla_ lock wait timeout exceeded _bla_\");\n        })\n                .doAnswer(invocation -> {\n                    throw new SQLException(\"bla_bla_ lock wait timeout exceeded _bla_\");\n                })\n                .doAnswer(invocation -> {\n                    throw new SQLException(\"bla_bla_ lock wait timeout exceeded _bla_\");\n                })\n                .doAnswer(invocation -> {\n                    throw new SQLException(\"bla_bla_ lock wait timeout exceeded _bla_\");\n                })\n                .doAnswer(invocation -> {\n                    throw new SQLException(\"bla_bla_ lock wait timeout exceeded _bla_\");\n                })\n                .doNothing()\n                .when(updateToDB).run();\n\n        try {\n            classUnderTest.run(updateToDB);\n        } catch (RuntimeException e) {\n            verify(updateToDB, times(5)).run();\n        }\n    }\n}", "output_text": "package com.kenshoo.pl.entity;\n\nimport com.google.api.gax.core.FixedCredentialsProvider;\nimport com.google.auth.oauth2.GoogleCredentials;\nimport com.google.cloud.spanner.AbortedException;\nimport com.google.cloud.spanner.DatabaseClient;\nimport com.google.cloud.spanner.Spanner;\nimport com.google.cloud.spanner.SpannerOptions;\nimport com.google.cloud.spanner.TransactionContext;\nimport com.google.cloud.spanner.TransactionRunner;\nimport com.google.cloud.spanner.TransactionRunner.TransactionCallable;\nimport com.google.cloud.spanner.TransactionRunnerImpl;\nimport com.google.cloud.spanner.TransactionRunnerImpl.TransactionContextImpl;\nimport com.kenshoo.pl.entity.spi.ThrowingAction;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.util.Properties;\n\nimport static org.mockito.Mockito.*;\n\npublic class DeadlockRetryerTest {\n\n    private DeadlockRetryer classUnderTest;\n    private ThrowingAction updateToDB = mock(ThrowingAction.class);\n    private DatabaseClient dbClient;\n\n    @Before\n    public void setUp() throws IOException {\n        Properties props = readProperties(\"/spanner.properties\");\n        \n        GoogleCredentials credentials = GoogleCredentials.fromStream(\n            new FileInputStream(props.getProperty(\"credentialsPath\"))); // Path to your JSON credentials file\n        \n        SpannerOptions options = SpannerOptions.newBuilder()\n            .setCredentials(credentials)\n            .setProjectId(props.getProperty(\"projectId\"))\n            .build();\n\n        Spanner spanner = options.getService();\n        dbClient = spanner.getDatabaseClient(\n            props.getProperty(\"instanceId\"), props.getProperty(\"databaseId\"));\n        \n        classUnderTest = new DeadlockRetryer(new SpannerDeadlockDetector(), () -> false)\n            .setFirstSleepBetweenRetriesMillis(1)\n            .setIncrementSleepBetweenRetriesMillis(1)\n            .setMaxDeadlockRetries(5);\n    }\n\n    @Test\n    public void update_Should_succeed_in_case_of_no_exceptions() throws Exception {\n        runUpdate();\n        verify(updateToDB, times(1)).run();\n    }\n\n    @Test\n    public void update_should_retry_when_AbortedException_occurs() throws Exception {\n        doThrow(AbortedException.class)\n            .doThrow(AbortedException.class)\n            .doThrow(AbortedException.class)\n            .doNothing()\n            .when(updateToDB).run();\n\n        runUpdate();\n        verify(updateToDB, times(4)).run();\n    }\n\n    @Test\n    public void update_should_not_retry_on_non_AbortedException_types() throws Exception {\n        doThrow(RuntimeException.class)\n            .doThrow(RuntimeException.class)\n            .doThrow(RuntimeException.class)\n            .doNothing()\n            .when(updateToDB).run();\n\n        try {\n            runUpdate();\n        } catch (RuntimeException e) {\n            verify(updateToDB, times(1)).run();\n        }\n    }\n\n    @Test\n    public void update_should_stop_retrying_after_max_number_of_attempts() throws Exception {\n        doThrow(AbortedException.class)\n            .doThrow(AbortedException.class)\n            .doThrow(AbortedException.class)\n            .doThrow(AbortedException.class)\n            .doThrow(AbortedException.class)\n            .doNothing()\n            .when(updateToDB).run();\n\n        try {\n            runUpdate();\n        } catch (RuntimeException e) {\n            verify(updateToDB, times(5)).run();\n        }\n    }\n\n    private void runUpdate() throws Exception {\n        TransactionRunner txnRunner = dbClient.readWriteTransaction();\n        txnRunner.run(new TransactionCallable<Void>() {\n            @Override\n            public Void run(TransactionContext transactionContext) throws Exception {\n                classUnderTest.run(updateToDB);\n                return null;\n            }\n        });\n    }\n\n    private Properties readProperties(String resourceName) {\n        try {\n            Properties props = new Properties();\n            props.load(DeadlockRetryerTest.class.getResourceAsStream(resourceName));\n            return props;\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n\nclass SpannerDeadlockDetector implements DeadlockDetector {\n    @Override\n    public boolean isDeadlock(Exception exception) {\n        // Check if the exception indicates a deadlock or transient transaction error\n        return (exception instanceof AbortedException);\n    }\n}\n\ninterface DeadlockDetector {\n    boolean isDeadlock(Exception exception);\n}\n\nclass DeadlockRetryer {\n    private DeadlockDetector detector;\n    private ThrowingAction action;\n    private boolean alwaysRetry;\n    private int firstSleepMillis;\n    private int incrementSleepMillis;\n    private int maxRetries;\n\n    public DeadlockRetryer(DeadlockDetector detector, ThrowingAction action) {\n        this.detector = detector;\n        this.action = action;\n    }\n\n    public DeadlockRetryer setFirstSleepBetweenRetriesMillis(int firstSleepMillis) {\n        this.firstSleepMillis = firstSleepMillis;\n        return this;\n    }\n\n    public DeadlockRetryer setIncrementSleepBetweenRetriesMillis(int incrementSleepMillis) {\n        this.incrementSleepMillis = incrementSleepMillis;\n        return this;\n    }\n\n    public DeadlockRetryer setMaxDeadlockRetries(int maxRetries) {\n        this.maxRetries = maxRetries;\n        return this;\n    }\n\n    public void run(ThrowingAction action) throws Exception {\n        int retries = 0;\n        while (true) {\n            try {\n                action.run();\n                return; // If successful, exit retry loop\n            } catch (Exception ex) {\n                if (!detector.isDeadlock(ex) || retries >= maxRetries) {\n                    throw ex; // Rethrow if not a deadlock or reached max retries\n                }\n                // Sleep before retry\n                Thread.sleep(firstSleepMillis + (retries * incrementSleepMillis));\n                retries++;\n            }\n        }\n    }\n}\n\n@FunctionalInterface\ninterface ThrowingAction {\n    void run() throws Exception;\n}\n"}
{"input_text": "convert following Java code from MySQL to Spanner \npackage com.kenshoo.pl.entity;\r\n\r\nimport com.google.common.base.Throwables;\r\nimport com.google.common.collect.ImmutableList;\r\nimport com.google.common.collect.Iterables;\r\nimport com.kenshoo.jooq.AbstractDataTable;\r\nimport com.kenshoo.jooq.DataTable;\r\nimport com.kenshoo.jooq.DataTableUtils;\r\nimport com.kenshoo.jooq.TestJooqConfig;\r\nimport com.kenshoo.pl.entity.mysql.MySqlDeadlockDetector;\r\nimport com.kenshoo.pl.entity.spi.OutputGenerator;\r\nimport org.apache.commons.lang3.RandomStringUtils;\r\nimport org.jooq.DSLContext;\r\nimport org.jooq.Record;\r\nimport org.jooq.TableField;\r\nimport org.jooq.impl.SQLDataType;\r\nimport org.junit.*;\r\n\r\nimport java.sql.SQLException;\r\nimport java.util.Collection;\r\nimport java.util.concurrent.*;\r\nimport java.util.concurrent.atomic.AtomicReference;\r\nimport java.util.stream.Stream;\r\n\r\nimport static org.hamcrest.Matchers.*;\r\nimport static org.junit.Assert.*;\r\n\r\n@Ignore\r\npublic class TimeoutTest {\r\n\r\n    private static final int ID = 1;\r\n\r\n    private static final Object[][] DATA = {\r\n            {ID, \"Alpha\"},\r\n    };\r\n\r\n    private static final String UPDATE_VALUE = \"Beta\";\r\n    private static final String RETRY_VALUE = \"Gamma\";\r\n\r\n    private DSLContext dslContext = TestJooqConfig.create();\r\n\r\n    private PersistenceLayer<TestEntityType> persistenceLayer;\r\n\r\n    private static TestTable table1;\r\n    private static TestEntityType entityType;\r\n    private static DSLContext staticDSLContext;\r\n\r\n    @AfterClass\r\n    public static void dropTables() {\r\n        staticDSLContext.dropTableIfExists(table1).execute();\r\n    }\r\n\r\n    @Before\r\n    public void setup() {\r\n\r\n        persistenceLayer = new PersistenceLayer<>(dslContext);\r\n\r\n        if (table1 == null) {\r\n            String tableName1 = RandomStringUtils.randomAlphanumeric(15);\r\n            table1 = new TestTable(tableName1);\r\n            DataTableUtils.createTable(dslContext, table1);\r\n\r\n            entityType = new TestEntityType();\r\n            staticDSLContext = dslContext;\r\n        }\r\n        DataTableUtils.populateTable(dslContext, table1, DATA);\r\n    }\r\n\r\n    @After\r\n    public void clearTables() {\r\n        dslContext.deleteFrom(table1).execute();\r\n    }\r\n\r\n    @Test\r\n    public void timeoutOutWithNoRetries() throws InterruptedException {\r\n        DeadlockRetryer dataBaseRetryer = createDataBaseRetryer(1);\r\n        PLContext plContext = new PLContext.Builder(dslContext).withRetryer(dataBaseRetryer).build();\r\n        AtomicReference<Exception> exception = runTwoLockingThreads(plContext);\r\n        assertNotNull(exception.get());\r\n        Throwable expectedException = Throwables.getRootCause(exception.get());\r\n        assertThat(expectedException, is(instanceOf(SQLException.class)));\r\n        assertThat(expectedException.getMessage(), containsString(\"Lock wait timeout exceeded\"));\r\n    }\r\n\r\n    @Test\r\n    public void noTimeoutOutWithRetries() throws InterruptedException {\r\n        DeadlockRetryer dataBaseRetryer = createDataBaseRetryer(3);\r\n        PLContext plContext = new PLContext.Builder(dslContext).withRetryer(dataBaseRetryer).build();\r\n        AtomicReference<Exception> exception = runTwoLockingThreads(plContext);\r\n        assertNull(exception.get());\r\n    }\r\n\r\n    private DeadlockRetryer createDataBaseRetryer(int maxDeadlockRetries) {\r\n        DeadlockRetryer dataBaseRetryer = new DeadlockRetryer(new MySqlDeadlockDetector(), () -> false);\r\n        dataBaseRetryer.setMaxDeadlockRetries(maxDeadlockRetries);\r\n        dataBaseRetryer.setFirstSleepBetweenRetriesMillis(50);\r\n        return dataBaseRetryer;\r\n    }\r\n\r\n    private AtomicReference<Exception> runTwoLockingThreads(PLContext plContext) throws InterruptedException {\r\n        ExecutorService executorService = Executors.newFixedThreadPool(2);\r\n        AtomicReference<Exception> exception = new AtomicReference<>();\r\n        CountDownLatch latch = new CountDownLatch(1);\r\n        CountDownLatch latch2 = new CountDownLatch(1);\r\n        OutputGenerator<TimeoutTest.TestEntityType> lockOutputGenerator = new TimeoutTest.LockOutputGenerator(table1, latch, latch2);\r\n        ChangeFlowConfig<TimeoutTest.TestEntityType> lockFlowConfig = ChangeFlowConfigBuilderFactory.newInstance(plContext, entityType).withoutOutputGenerators().withOutputGenerator(lockOutputGenerator).build();\r\n\r\n        Future<?> lockTask = executorService.submit(() -> {\r\n            persistenceLayer.update(ImmutableList.of(createUpdCmd(UPDATE_VALUE)), lockFlowConfig);\r\n        });\r\n\r\n        OutputGenerator<TimeoutTest.TestEntityType> timeoutOutputGenerator = new TimeoutTest.TimeoutOutputGenerator(table1, latch, latch2);\r\n        ChangeFlowConfig<TimeoutTest.TestEntityType> timeOutflowConfig = ChangeFlowConfigBuilderFactory.newInstance(plContext, entityType).withoutOutputGenerators().withOutputGenerator(timeoutOutputGenerator).build();\r\n\r\n        Future<?> timeOutTask = executorService.submit(() -> {\r\n            try {\r\n                persistenceLayer.update(ImmutableList.of(createUpdCmd(RETRY_VALUE)), timeOutflowConfig);\r\n            } catch (Exception e) {\r\n                exception.set(e);\r\n            }\r\n        });\r\n\r\n        waitTasks(lockTask, timeOutTask);\r\n\r\n        executorService.shutdown();\r\n        executorService.awaitTermination(1, TimeUnit.SECONDS);\r\n        return exception;\r\n    }\r\n\r\n    private UpdateEntityCommand<TestEntityType, TestEntityType.Key> createUpdCmd(String retryValue) {\r\n        UpdateEntityCommand<TestEntityType, TestEntityType.Key> cmd = new UpdateEntityCommand<>(entityType, new TestEntityType.Key(ID));\r\n        cmd.set(TestEntityType.FIELD, retryValue);\r\n        return cmd;\r\n    }\r\n\r\n    private void waitTasks(Future<?> task1, Future<?> task2) {\r\n        ImmutableList.of(task1, task2).forEach(t -> {\r\n            try {\r\n                t.get();\r\n            } catch (InterruptedException | ExecutionException e) {\r\n                e.printStackTrace();\r\n            }\r\n        });\r\n    }\r\n\r\n    private static class TestTable extends AbstractDataTable<TestTable> {\r\n\r\n        private final TableField<Record, Integer> id = createPKField(\"id\", SQLDataType.INTEGER);\r\n        private final TableField<Record, String> field = createField(\"field\", SQLDataType.VARCHAR.length(50));\r\n\r\n        public TestTable(String name) {\r\n            super(name);\r\n        }\r\n\r\n        public TestTable(TestTable aliased, String alias) {\r\n            super(aliased, alias);\r\n        }\r\n\r\n        @Override\r\n        public TestTable as(String alias) {\r\n            return new TestTable(this, alias);\r\n        }\r\n    }\r\n\r\n    public static class TestEntityType extends AbstractEntityType<TestEntityType> {\r\n\r\n        public static final TestEntityType INSTANCE = new TestEntityType();\r\n\r\n        public static final EntityField<TestEntityType, Integer> ID = INSTANCE.field(table1.id);\r\n        public static final EntityField<TestEntityType, String> FIELD = INSTANCE.field(table1.field);\r\n\r\n        protected TestEntityType() {\r\n            super(\"test\");\r\n        }\r\n\r\n        @Override\r\n        public DataTable getPrimaryTable() {\r\n            return table1;\r\n        }\r\n\r\n        public static class Key extends SingleUniqueKeyValue<TestEntityType, Integer> {\r\n            public static final SingleUniqueKey<TestEntityType, Integer> DEFINITION = new SingleUniqueKey<TestEntityType, Integer>(ID) {\r\n                @Override\r\n                protected SingleUniqueKeyValue<TestEntityType, Integer> createValue(Integer value) {\r\n                    return new Key(value);\r\n                }\r\n            };\r\n\r\n            public Key(int val) {\r\n                super(DEFINITION, val);\r\n            }\r\n        }\r\n    }\r\n\r\n    private class LockOutputGenerator implements OutputGenerator<TestEntityType> {\r\n\r\n        private final TestTable table1;\r\n        private final CountDownLatch startTimpouThread;\r\n        private final CountDownLatch finishLockingThread;\r\n\r\n        LockOutputGenerator(TestTable table1, CountDownLatch latch, CountDownLatch latch2) {\r\n            this.table1 = table1;\r\n            this.startTimpouThread = latch;\r\n            this.finishLockingThread = latch2;\r\n        }\r\n\r\n        @Override\r\n        public void generate(Collection<? extends EntityChange<TestEntityType>> entityChanges, ChangeOperation changeOperation, ChangeContext changeContext) {\r\n            try {\r\n                EntityChange<TestEntityType> first = Iterables.getFirst(entityChanges, null);\r\n                dslContext.update(table1).set(table1.field, first.get(TestEntityType.FIELD)).where(table1.id.eq(first.getIdentifier().get(TestEntityType.ID))).execute();\r\n                finishLockingThread.countDown();\r\n                try {\r\n                    startTimpouThread.await();\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }\r\n\r\n            } catch (Exception e) {\r\n                throw Throwables.propagate(e);\r\n            } finally {\r\n                finishLockingThread.countDown();\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public Stream<? extends EntityField<?, ?>> requiredFields(Collection<? extends EntityField<TestEntityType, ?>> fieldsToUpdate, ChangeOperation changeOperation) {\r\n            return Stream.empty();\r\n        }\r\n    }\r\n\r\n    private class TimeoutOutputGenerator implements OutputGenerator<TestEntityType> {\r\n\r\n        private final TestTable table1;\r\n        private final CountDownLatch latch;\r\n        private final CountDownLatch latch2;\r\n\r\n        TimeoutOutputGenerator(TestTable table1, CountDownLatch latch, CountDownLatch latch2) {\r\n            this.table1 = table1;\r\n            this.latch = latch;\r\n            this.latch2 = latch2;\r\n        }\r\n\r\n        @Override\r\n        public void generate(Collection<? extends EntityChange<TestEntityType>> entityChanges, ChangeOperation changeOperation, ChangeContext changeContext) {\r\n            try {\r\n                latch2.await();\r\n                EntityChange<TestEntityType> first = Iterables.getFirst(entityChanges, null);\r\n                dslContext.execute(\"SET SESSION innodb_lock_wait_timeout = 1\");\r\n                dslContext.update(table1).set(table1.field, first.get(TestEntityType.FIELD)).where(table1.id.eq(first.getIdentifier().get(TestEntityType.ID))).execute();\r\n            } catch (Exception e) {\r\n                throw Throwables.propagate(e);\r\n            } finally {\r\n                latch.countDown();\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public Stream<? extends EntityField<?, ?>> requiredFields(Collection<? extends EntityField<TestEntityType, ?>> fieldsToUpdate, ChangeOperation changeOperation) {\r\n            return Stream.empty();\r\n        }\r\n    }\r\n}", "output_text": "package com.kenshoo.pl.entity;\n\nimport com.google.cloud.spanner.DatabaseClient;\nimport com.google.cloud.spanner.DatabaseId;\nimport com.google.cloud.spanner.Key;\nimport com.google.cloud.spanner.KeySet;\nimport com.google.cloud.spanner.Mutation;\nimport com.google.cloud.spanner.Spanner;\nimport com.google.cloud.spanner.SpannerOptions;\nimport com.google.cloud.spanner.TransactionContext;\nimport com.google.cloud.spanner.TransactionRunner;\nimport com.google.cloud.spanner.TransactionRunner.TransactionCallable;\nimport com.google.cloud.spanner.spi.v1.SpannerInterceptor;\nimport com.google.common.collect.ImmutableList;\nimport com.kenshoo.jooq.TestJooqConfig;\nimport com.kenshoo.pl.entity.AbstractEntityType;\nimport com.kenshoo.pl.entity.ChangeContext;\nimport com.kenshoo.pl.entity.ChangeFlowConfig;\nimport com.kenshoo.pl.entity.ChangeOperation;\nimport com.kenshoo.pl.entity.EntityChange;\nimport com.kenshoo.pl.entity.EntityField;\nimport com.kenshoo.pl.entity.PersistenceLayer;\nimport com.kenshoo.pl.entity.UpdateEntityCommand;\nimport com.kenshoo.pl.entity.spi.OutputGenerator;\nimport com.kenshoo.pl.entity.spi.PlContext;\nimport com.kenshoo.pl.entity.spi.PlContext.Builder;\nimport com.kenshoo.pl.entity.spi.ThrowingAction;\nimport com.kenshoo.pl.entity.mysql.MySqlDeadlockDetector;\nimport org.apache.commons.lang3.RandomStringUtils;\nimport org.jooq.DSLContext;\nimport org.jooq.impl.SQLDataType;\nimport org.junit.After;\nimport org.junit.AfterClass;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.util.Collection;\nimport java.util.Properties;\nimport java.util.concurrent.*;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.stream.Stream;\n\nimport static org.hamcrest.Matchers.*;\nimport static org.junit.Assert.*;\n\npublic class TimeoutTest {\n\n    private static final int ID = 1;\n\n    private static final Object[][] DATA = {\n            {ID, \"Alpha\"},\n    };\n\n    private static final String UPDATE_VALUE = \"Beta\";\n    private static final String RETRY_VALUE = \"Gamma\";\n\n    private DatabaseClient dbClient;\n    private PersistenceLayer<TestEntityType> persistenceLayer;\n\n    private static TestTable table1;\n    private static TestEntityType entityType;\n\n    @Before\n    public void setUp() throws IOException {\n        Properties props = readProperties(\"/spanner.properties\");\n\n        SpannerOptions options = SpannerOptions.newBuilder()\n            .setProjectId(props.getProperty(\"projectId\"))\n            .setCredentials(\n                GoogleCredentials.fromStream(new FileInputStream(props.getProperty(\"credentialsPath\"))))\n            .build();\n\n        Spanner spanner = options.getService();\n        DatabaseId dbId = DatabaseId.of(options.getProjectId(), props.getProperty(\"instanceId\"), props.getProperty(\"databaseId\"));\n        dbClient = spanner.getDatabaseClient(dbId);\n\n        DSLContext dslContext = TestJooqConfig.create(new SpannerConnectionProvider(dbClient));\n        persistenceLayer = new PersistenceLayer<>(dslContext);\n\n        if (table1 == null) {\n            String tableName1 = RandomStringUtils.randomAlphanumeric(15);\n            table1 = new TestTable(tableName1);\n            createSpannerTable(table1);\n\n            entityType = new TestEntityType();\n        }\n        populateSpannerTable(table1, DATA);\n    }\n\n    @After\n    public void tearDown() {\n        dbClient.writeAtLeastOnce(ImmutableList.of(\n            Mutation.delete(table1.tableName()).build()));\n    }\n\n    @AfterClass\n    public static void dropTables() {\n        // Drop the table after all tests\n        dbClient.writeAtLeastOnce(ImmutableList.of(\n            Mutation.dropTable(table1.tableName()).build()));\n    }\n\n    @Test\n    public void timeoutOutWithNoRetries() throws InterruptedException {\n        DeadlockRetryer dataBaseRetryer = createDataBaseRetryer(1);\n        PlContext plContext = new PlContext.Builder(dbClient).withRetryer(dataBaseRetryer).build();\n        AtomicReference<Exception> exception = runTwoLockingThreads(plContext);\n        assertNotNull(exception.get());\n        Throwable expectedException = exception.get();\n        assertThat(expectedException, is(instanceOf(SQLException.class)));\n        assertThat(expectedException.getMessage(), containsString(\"Aborted due to concurrency conflict\"));\n    }\n\n    @Test\n    public void noTimeoutOutWithRetries() throws InterruptedException {\n        DeadlockRetryer dataBaseRetryer = createDataBaseRetryer(3);\n        PlContext plContext = new PlContext.Builder(dbClient).withRetryer(dataBaseRetryer).build();\n        AtomicReference<Exception> exception = runTwoLockingThreads(plContext);\n        assertNull(exception.get());\n    }\n\n    private DeadlockRetryer createDataBaseRetryer(int maxDeadlockRetries) {\n        DeadlockRetryer dataBaseRetryer = new DeadlockRetryer(new SpannerDeadlockDetector(), () -> false);\n        dataBaseRetryer.setMaxDeadlockRetries(maxDeadlockRetries);\n        dataBaseRetryer.setFirstSleepBetweenRetriesMillis(50);\n        return dataBaseRetryer;\n    }\n\n    private AtomicReference<Exception> runTwoLockingThreads(PlContext plContext) throws InterruptedException {\n        ExecutorService executorService = Executors.newFixedThreadPool(2);\n        AtomicReference<Exception> exception = new AtomicReference<>();\n        CountDownLatch latch = new CountDownLatch(1);\n        CountDownLatch latch2 = new CountDownLatch(1);\n        OutputGenerator<TestEntityType> lockOutputGenerator = new LockOutputGenerator(table1, latch, latch2);\n        ChangeFlowConfig<TestEntityType> lockFlowConfig = ChangeFlowConfigBuilderFactory.newInstance(plContext, entityType).withoutOutputGenerators().withOutputGenerator(lockOutputGenerator).build();\n\n        Future<?> lockTask = executorService.submit(() -> {\n            persistenceLayer.update(ImmutableList.of(createUpdCmd(UPDATE_VALUE)), lockFlowConfig);\n        });\n\n        OutputGenerator<TestEntityType> timeoutOutputGenerator = new TimeoutOutputGenerator(table1, latch, latch2);\n        ChangeFlowConfig<TestEntityType> timeOutflowConfig = ChangeFlowConfigBuilderFactory.newInstance(plContext, entityType).withoutOutputGenerators().withOutputGenerator(timeoutOutputGenerator).build();\n\n        Future<?> timeOutTask = executorService.submit(() -> {\n            try {\n                persistenceLayer.update(ImmutableList.of(createUpdCmd(RETRY_VALUE)), timeOutflowConfig);\n            } catch (Exception e) {\n                exception.set(e);\n            }\n        });\n\n        waitTasks(lockTask, timeOutTask);\n\n        executorService.shutdown();\n        executorService.awaitTermination(1, TimeUnit.SECONDS);\n        return exception;\n    }\n\n    private UpdateEntityCommand<TestEntityType, TestEntityType.Key> createUpdCmd(String retryValue) {\n        UpdateEntityCommand<TestEntityType, TestEntityType.Key> cmd = new UpdateEntityCommand<>(entityType, new TestEntityType.Key(ID));\n        cmd.set(TestEntityType.FIELD, retryValue);\n        return cmd;\n    }\n\n    private void waitTasks(Future<?> task1, Future<?> task2) {\n        ImmutableList.of(task1, task2).forEach(t -> {\n            try {\n                t.get();\n            } catch (InterruptedException | ExecutionException e) {\n                e.printStackTrace();\n            }\n        });\n    }\n\n    private void createSpannerTable(TestTable table) {\n        // Create table in Spanner\n        dbClient.updateDdl(\"CREATE TABLE \" + table.tableName() + \" (\"\n            + \"id INT64 NOT NULL,\"\n            + \"field STRING(50),\"\n            + \") PRIMARY KEY (id)\").get();\n    }\n\n    private void populateSpannerTable(TestTable table, Object[][] data) {\n        // Populate table in Spanner\n        for (Object[] row : data) {\n            dbClient.writeAtLeastOnce(\n                ImmutableList.of(Mutation.newInsertBuilder(table.tableName())\n                    .set(\"id\").to((Long) row[0])\n                    .set(\"field\").to((String) row[1])\n                    .build()));\n        }\n    }\n\n    private Properties readProperties(String resourceName) {\n        try {\n            Properties props = new Properties();\n            props.load(TimeoutTest.class.getResourceAsStream(resourceName));\n            return props;\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private static class TestTable {\n        private final String tableName;\n        TestTable(String tableName) {\n            this.tableName = tableName;\n        }\n        String tableName() {\n            return tableName;\n        }\n    }\n\n    public static class TestEntityType extends AbstractEntityType<TestEntityType> {\n        public static final TestEntityType INSTANCE = new TestEntityType();\n        public static final EntityField<TestEntityType, Long> ID = INSTANCE.field(\"id\", SQLDataType.INT64);\n        public static final EntityField<TestEntityType, String> FIELD = INSTANCE.field(\"field\", SQLDataType.STRING);\n\n        protected TestEntityType() {\n            super(\"test\");\n        }\n\n        @Override\n        public Collection<? extends EntityField<TestEntityType, ?>> fields() {\n            return ImmutableList.of(ID, FIELD);\n        }\n    }\n\n    private class LockOutputGenerator implements OutputGenerator<TestEntityType> {\n        private final TestTable table1;\n        private final CountDownLatch startTimpouThread;\n        private final CountDownLatch finishLockingThread;\n\n        LockOutputGenerator(TestTable table1, CountDownLatch latch, CountDownLatch latch2) {\n            this.table1 = table1;\n            this.startTimpouThread = latch;\n            this.finishLockingThread = latch2;\n        }\n\n        @Override\n        public void generate(Collection<? extends EntityChange<TestEntityType>> entityChanges, ChangeOperation changeOperation, ChangeContext changeContext) {\n            try {\n                EntityChange<TestEntityType> first = entityChanges.iterator().next();\n                dbClient.readWriteTransaction().run(new TransactionCallable<Void>() {\n                    @Override\n                    public Void run(TransactionContext transactionContext) throws Exception {\n                        dbClient.writeAtLeastOnce(ImmutableList.of(Mutation.newUpdateBuilder(table1.tableName())\n                            .set(\"field\").to(first.get(TestEntityType.FIELD))\n                            .where(ComposedKey.of(KeySet.singleKey(transactionContext.getTimestamp()), Key.of(first.get(TestEntityType.ID))))\n                            .build()));\n                        finishLockingThread.countDown();\n                        try {\n                            startTimpouThread.await();\n                        } catch (InterruptedException e) {\n                            e.printStackTrace();\n                        }\n                        return null;\n                    }\n                });\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            } finally {\n                finishLockingThread.countDown();\n            }\n        }\n\n        @Override\n        public Stream<? extends EntityField<?, ?>> requiredFields(Collection<? extends EntityField<TestEntityType, ?>> fieldsToUpdate, ChangeOperation changeOperation) {\n            return Stream.empty();\n        }\n    }\n\n    private class TimeoutOutputGenerator implements OutputGenerator<TestEntityType> {\n        private final TestTable table1;\n        private final CountDownLatch latch;\n        private final CountDownLatch latch2;\n\n        TimeoutOutputGenerator(TestTable table1, CountDownLatch latch, CountDownLatch latch2) {\n            this.table1 = table1;\n            this.latch = latch;\n            this.latch2 = latch2;\n        }\n\n        @Override\n        public void generate(Collection<? extends EntityChange<TestEntityType>> entityChanges, ChangeOperation changeOperation, ChangeContext changeContext) {\n            try {\n                latch2.await();\n                EntityChange<TestEntityType> first = entityChanges.iterator().next();\n                dbClient.readWriteTransaction().run(new TransactionCallable<Void>() {\n                    @Override\n                    public Void run(TransactionContext transactionContext) throws Exception {\n                        dbClient.writeAtLeastOnce(ImmutableList.of(Mutation.newUpdateBuilder(table1.tableName())\n                            .set(\"field\").to(first.get(TestEntityType.FIELD))\n                            .where(ComposedKey.of(KeySet.singleKey(transactionContext.getTimestamp()), Key.of(first.get(TestEntityType.ID))))\n                            .build()));\n                        return null;\n                    }\n                });\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            } finally {\n                latch.countDown();\n            }\n        }\n\n        @Override\n        public Stream<? extends EntityField<?, ?>> requiredFields(Collection<? extends EntityField<TestEntityType, ?>> fieldsToUpdate, ChangeOperation changeOperation) {\n            return Stream.empty();\n        }\n    }\n}\n"}
{"input_text": "convert following Java code from MySQL to Spanner \npackage com.kenshoo.jooq;\r\n\r\nimport com.google.common.collect.ImmutableList;\r\nimport org.jooq.DSLContext;\r\nimport org.jooq.Field;\r\nimport org.jooq.Record;\r\nimport org.jooq.impl.TableImpl;\r\n\r\nimport java.util.Collection;\r\n\r\n/**\r\n * Provides a convenient (and MySQL-friendly) way of solving the use-case of deleting records by N identifiers.\r\n * The simplest case is deleting by a list of IDs in which case it could be expressed with a simple IN. However in\r\n * terms of performance (and logs) it's better to do a join with a temporary table populated with those IDs instead.\r\n * This class does it automatically.\r\n *\r\n * <b>The returned object is a resource and it is crucial to place it inside try/finally block so it could be closed</b>\r\n */\r\npublic class DeleteQueryBuilder {\r\n\r\n    private final DSLContext dslContext;\r\n\r\n    public DeleteQueryBuilder(DSLContext dslContext) {\r\n        this.dslContext = dslContext;\r\n    }\r\n\r\n    public BuilderWith table(final TableImpl<Record> table) {\r\n\r\n        return new BuilderWith() {\r\n            @Override\r\n            public <T> BuilderIn1<T> withCondition(final Field<T> field) {\r\n                return values -> new DeleteQueryExtension(table, ImmutableList.of(\r\n                        new FieldAndValues<>(field, values)),\r\n                        dslContext);\r\n            }\r\n        };\r\n    }\r\n\r\n\r\n    public interface BuilderWith {\r\n        <T> BuilderIn1 withCondition(Field<T> field);\r\n    }\r\n\r\n\r\n    public interface BuilderIn1<T> {\r\n        DeleteQueryExtension in(Collection<T> values);\r\n    }\r\n}\r\n", "output_text": "package com.kenshoo.jooq;\n\nimport com.google.cloud.spanner.DatabaseClient;\nimport com.google.cloud.spanner.Mutation;\nimport com.google.cloud.spanner.Statement;\nimport com.google.common.collect.ImmutableList;\nimport org.jooq.DSLContext;\nimport org.jooq.Field;\nimport org.jooq.Record;\nimport org.jooq.impl.TableImpl;\n\nimport java.util.Collection;\n\npublic class DeleteQueryBuilder {\n\n    private final DatabaseClient dbClient;\n\n    public DeleteQueryBuilder(DatabaseClient dbClient) {\n        this.dbClient = dbClient;\n    }\n\n    public BuilderWith table(final TableImpl<Record> table) {\n        return new BuilderWith() {\n            @Override\n            public <T> BuilderIn1<T> withCondition(final Field<T> field) {\n                return values -> new DeleteQueryExtension(table, ImmutableList.of(new FieldAndValues<>(field, values)), dbClient);\n            }\n        };\n    }\n\n    public interface BuilderWith {\n        <T> BuilderIn1<T> withCondition(Field<T> field);\n    }\n\n    public interface BuilderIn1<T> {\n        DeleteQueryExtension in(Collection<T> values);\n    }\n\n    public static class DeleteQueryExtension {\n        private final TableImpl<Record> table;\n        private final Collection<FieldAndValues<?>> conditions;\n        private final DatabaseClient dbClient;\n\n        public DeleteQueryExtension(TableImpl<Record> table, Collection<FieldAndValues<?>> conditions, DatabaseClient dbClient) {\n            this.table = table;\n            this.conditions = conditions;\n            this.dbClient = dbClient;\n        }\n\n        public void execute() {\n            dbClient.readWriteTransaction()\n                    .run(transaction -> {\n                        Statement.Builder builder = Statement.newBuilder(\"DELETE FROM \" + table.getName());\n\n                        if (!conditions.isEmpty()) {\n                            builder.append(\" WHERE \");\n                            boolean first = true;\n                            for (FieldAndValues<?> condition : conditions) {\n                                if (!first) {\n                                    builder.append(\" AND \");\n                                }\n                                appendCondition(builder, condition.getField(), condition.getValues());\n                                first = false;\n                            }\n                        }\n\n                        Statement statement = builder.build();\n                        transaction.executeUpdate(statement);\n                        return null;\n                    });\n        }\n\n        private <T> void appendCondition(Statement.Builder builder, Field<T> field, Collection<T> values) {\n            builder.append(field.getName()).append(\" IN (\");\n            boolean first = true;\n            for (T value : values) {\n                if (!first) {\n                    builder.append(\", \");\n                }\n                builder.append(value.toString());\n                first = false;\n            }\n            builder.append(\")\");\n        }\n    }\n\n    // Field and values holder, similar to FieldAndValues in original code\n    private static class FieldAndValues<T> {\n        private final Field<T> field;\n        private final Collection<T> values;\n\n        FieldAndValues(Field<T> field, Collection<T> values) {\n            this.field = field;\n            this.values = values;\n        }\n\n        public Field<T> getField() {\n            return field;\n        }\n\n        public Collection<T> getValues() {\n            return values;\n        }\n    }\n}\n"}
{"input_text": "convert following Java code from MySQL to Spanner \npackage com.kenshoo.jooq;\r\n\r\nimport com.google.common.collect.ImmutableList;\r\nimport com.kenshoo.pl.entity.*;\r\nimport com.kenshoo.pl.entity.UniqueKey;\r\nimport org.jooq.*;\r\nimport org.jooq.lambda.tuple.Tuple2;\r\nimport org.jooq.lambda.tuple.Tuple3;\r\nimport org.jooq.lambda.tuple.Tuple4;\r\nimport org.jooq.lambda.tuple.Tuple5;\r\n\r\nimport java.util.Collection;\r\nimport java.util.List;\r\nimport java.util.stream.Stream;\r\n\r\nimport static java.util.stream.Collectors.toList;\r\n\r\n/**\r\n * Provides a convenient (and MySQL-friendly) way of solving the use-case of querying records by N-tuples of identifiers.\r\n * The simplest case is querying by a list of IDs in which case it could be expressed with a simple IN. However in\r\n * terms of performance (and logs) it's better to do a join with a temporary table populated with those IDs instead.\r\n * This class does it automatically. In the more complicated case where the lookup is done by two fields (e.g. profile/affcode),\r\n * it is impossible to express it with an IN condition and a temp table has to be used in this case.\r\n *\r\n * Example of simple usage:\r\n * <pre>\r\n * AdCriterias ac = AdCriterias.TABLE;\r\n * SelectConditionStep&lt;Record2&lt;String, Integer&gt;&gt; query = dslContext.select(ac.affcode, ac.criteria_id)\r\n *         .from(ac).where(ac.profile_id.eq(profileId));\r\n * try (QueryExtension&lt;SelectConditionStep&lt;Record2&lt;String, Integer&gt;&gt;&gt; queryExtension =\r\n *         SelectQueryExtender.of(query).withCondition(ac.affcode).in(affcodes)) {\r\n *     return queryExtension.getQuery().fetchMap(ac.affcode, ac.criteria_id);\r\n * }\r\n * </pre>\r\n * <b>The returned object is a resource and it is crucial to place it inside try/finally block so it could be closed</b>\r\n */\r\npublic class SelectQueryExtender {\r\n\r\n    public static <Q extends SelectFinalStep> QueryExtension<Q> of(final DSLContext dslContext, Q query, List<FieldAndValues<?>> conditions) {\r\n        return new QueryExtensionImpl<>(dslContext, query, conditions);\r\n    }\r\n\r\n    public static <Q extends SelectFinalStep> BuilderWith<Q> of(final DSLContext dslContext, final Q query) {\r\n        return new BuilderWith<Q>() {\r\n            @Override\r\n            public <T> BuilderIn1<Q, T> withCondition(final Field<T> field) {\r\n                return values -> new QueryExtensionImpl<>(dslContext, query, ImmutableList.of(new FieldAndValues<>(field, values)));\r\n            }\r\n\r\n            @Override\r\n            public <T1, T2> BuilderIn2<Q, T1, T2> withCondition(final Field<T1> field1, final Field<T2> field2) {\r\n                return values -> new QueryExtensionImpl<>(dslContext, query, ImmutableList.of(\r\n                        new FieldAndValues<>(field1, values.stream().map(Tuple2::v1).collect(toList())),\r\n                        new FieldAndValues<>(field2, values.stream().map(Tuple2::v2).collect(toList()))\r\n                ));\r\n            }\r\n\r\n            @Override\r\n            public <T1, T2, T3> BuilderIn3<Q, T1, T2, T3> withCondition(final Field<T1> field1, final Field<T2> field2, final Field<T3> field3) {\r\n                return values -> new QueryExtensionImpl<>(dslContext, query, ImmutableList.of(\r\n                        new FieldAndValues<>(field1, values.stream().map(Tuple3::v1).collect(toList())),\r\n                        new FieldAndValues<>(field2, values.stream().map(Tuple3::v2).collect(toList())),\r\n                        new FieldAndValues<>(field3, values.stream().map(Tuple3::v3).collect(toList()))\r\n                ));\r\n            }\r\n\r\n            @Override\r\n            public <T1, T2, T3, T4> BuilderIn4<Q, T1, T2, T3, T4> withCondition(final Field<T1> field1, final Field<T2> field2, final Field<T3> field3, final Field<T4> field4) {\r\n                return values -> new QueryExtensionImpl<>(dslContext, query, ImmutableList.of(\r\n                        new FieldAndValues<>(field1, values.stream().map(Tuple4::v1).collect(toList())),\r\n                        new FieldAndValues<>(field2, values.stream().map(Tuple4::v2).collect(toList())),\r\n                        new FieldAndValues<>(field3, values.stream().map(Tuple4::v3).collect(toList())),\r\n                        new FieldAndValues<>(field4, values.stream().map(Tuple4::v4).collect(toList()))\r\n                ));\r\n            }\r\n\r\n            @Override\r\n            public <T1, T2, T3, T4, T5> BuilderIn5<Q, T1, T2, T3, T4, T5> withCondition(final Field<T1> field1, final Field<T2> field2, final Field<T3> field3, final Field<T4> field4, final Field<T5> field5) {\r\n                return values -> new QueryExtensionImpl<>(dslContext, query, ImmutableList.of(\r\n                        new FieldAndValues<>(field1, values.stream().map(Tuple5::v1).collect(toList())),\r\n                        new FieldAndValues<>(field2, values.stream().map(Tuple5::v2).collect(toList())),\r\n                        new FieldAndValues<>(field3, values.stream().map(Tuple5::v3).collect(toList())),\r\n                        new FieldAndValues<>(field4, values.stream().map(Tuple5::v4).collect(toList())),\r\n                        new FieldAndValues<>(field5, values.stream().map(Tuple5::v5).collect(toList()))\r\n                        ));\r\n            }\r\n        };\r\n    }\r\n\r\n    public interface BuilderWith<Q extends SelectFinalStep> {\r\n        <T> BuilderIn1<Q, T> withCondition(Field<T> field);\r\n\r\n        <T1, T2> BuilderIn2<Q, T1, T2> withCondition(Field<T1> field1, Field<T2> field2);\r\n\r\n        <T1, T2, T3> BuilderIn3<Q, T1, T2, T3> withCondition(Field<T1> field1, Field<T2> field2, Field<T3> field3);\r\n\r\n        <T1, T2, T3, T4> BuilderIn4<Q, T1, T2, T3, T4> withCondition(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4);\r\n\r\n        <T1, T2, T3, T4, T5> BuilderIn5<Q, T1, T2, T3, T4, T5> withCondition(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5);\r\n    }\r\n\r\n    public interface BuilderIn1<Q extends SelectFinalStep, T> {\r\n        QueryExtension<Q> in(Collection<T> values);\r\n    }\r\n\r\n    public interface BuilderIn2<Q extends SelectFinalStep, T1, T2> {\r\n        QueryExtension<Q> in(Collection<Tuple2<T1, T2>> values);\r\n    }\r\n\r\n    public interface BuilderIn3<Q extends SelectFinalStep, T1, T2, T3> {\r\n        QueryExtension<Q> in(Collection<Tuple3<T1, T2, T3>> values);\r\n    }\r\n\r\n    public interface BuilderIn4<Q extends SelectFinalStep, T1, T2, T3, T4> {\r\n        QueryExtension<Q> in(Collection<Tuple4<T1, T2, T3, T4>> values);\r\n    }\r\n\r\n    public interface BuilderIn5<Q extends SelectFinalStep, T1, T2, T3, T4, T5> {\r\n        QueryExtension<Q> in(Collection<Tuple5<T1, T2, T3, T4, T5>> values);\r\n    }\r\n\r\n\r\n}\r", "output_text": "package com.kenshoo.jooq;\n\nimport com.google.cloud.spanner.DatabaseClient;\nimport com.google.cloud.spanner.Struct;\nimport com.google.cloud.spanner.Statement;\nimport com.google.cloud.spanner.StructReader;\nimport com.google.cloud.spanner.TransactionRunner;\nimport com.google.cloud.spanner.TransactionContext;\nimport com.google.cloud.spanner.Value;\nimport com.google.common.collect.ImmutableList;\nimport org.jooq.DSLContext;\nimport org.jooq.Field;\nimport org.jooq.SelectFinalStep;\nimport org.jooq.lambda.tuple.Tuple2;\nimport org.jooq.lambda.tuple.Tuple3;\nimport org.jooq.lambda.tuple.Tuple4;\nimport org.jooq.lambda.tuple.Tuple5;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\npublic class SelectQueryExtender {\n\n    public static <Q extends SelectFinalStep> QueryExtension<Q> of(final DatabaseClient dbClient, Q query, List<FieldAndValues<?>> conditions) {\n        return new QueryExtensionImpl<>(dbClient, query, conditions);\n    }\n\n    public static <Q extends SelectFinalStep> BuilderWith<Q> of(final DatabaseClient dbClient, final Q query) {\n        return new BuilderWith<Q>() {\n            @Override\n            public <T> BuilderIn1<Q, T> withCondition(final Field<T> field) {\n                return values -> new QueryExtensionImpl<>(dbClient, query, ImmutableList.of(new FieldAndValues<>(field, values)));\n            }\n\n            @Override\n            public <T1, T2> BuilderIn2<Q, T1, T2> withCondition(final Field<T1> field1, final Field<T2> field2) {\n                return values -> new QueryExtensionImpl<>(dbClient, query, ImmutableList.of(\n                        new FieldAndValues<>(field1, values.stream().map(Tuple2::v1).collect(Collectors.toList())),\n                        new FieldAndValues<>(field2, values.stream().map(Tuple2::v2).collect(Collectors.toList()))\n                ));\n            }\n\n            @Override\n            public <T1, T2, T3> BuilderIn3<Q, T1, T2, T3> withCondition(final Field<T1> field1, final Field<T2> field2, final Field<T3> field3) {\n                return values -> new QueryExtensionImpl<>(dbClient, query, ImmutableList.of(\n                        new FieldAndValues<>(field1, values.stream().map(Tuple3::v1).collect(Collectors.toList())),\n                        new FieldAndValues<>(field2, values.stream().map(Tuple3::v2).collect(Collectors.toList())),\n                        new FieldAndValues<>(field3, values.stream().map(Tuple3::v3).collect(Collectors.toList()))\n                ));\n            }\n\n            @Override\n            public <T1, T2, T3, T4> BuilderIn4<Q, T1, T2, T3, T4> withCondition(final Field<T1> field1, final Field<T2> field2, final Field<T3> field3, final Field<T4> field4) {\n                return values -> new QueryExtensionImpl<>(dbClient, query, ImmutableList.of(\n                        new FieldAndValues<>(field1, values.stream().map(Tuple4::v1).collect(Collectors.toList())),\n                        new FieldAndValues<>(field2, values.stream().map(Tuple4::v2).collect(Collectors.toList())),\n                        new FieldAndValues<>(field3, values.stream().map(Tuple4::v3).collect(Collectors.toList())),\n                        new FieldAndValues<>(field4, values.stream().map(Tuple4::v4).collect(Collectors.toList()))\n                ));\n            }\n\n            @Override\n            public <T1, T2, T3, T4, T5> BuilderIn5<Q, T1, T2, T3, T4, T5> withCondition(final Field<T1> field1, final Field<T2> field2, final Field<T3> field3, final Field<T4> field4, final Field<T5> field5) {\n                return values -> new QueryExtensionImpl<>(dbClient, query, ImmutableList.of(\n                        new FieldAndValues<>(field1, values.stream().map(Tuple5::v1).collect(Collectors.toList())),\n                        new FieldAndValues<>(field2, values.stream().map(Tuple5::v2).collect(Collectors.toList())),\n                        new FieldAndValues<>(field3, values.stream().map(Tuple5::v3).collect(Collectors.toList())),\n                        new FieldAndValues<>(field4, values.stream().map(Tuple5::v4).collect(Collectors.toList())),\n                        new FieldAndValues<>(field5, values.stream().map(Tuple5::v5).collect(Collectors.toList()))\n                ));\n            }\n        };\n    }\n\n    public interface BuilderWith<Q extends SelectFinalStep> {\n        <T> BuilderIn1<Q, T> withCondition(Field<T> field);\n\n        <T1, T2> BuilderIn2<Q, T1, T2> withCondition(Field<T1> field1, Field<T2> field2);\n\n        <T1, T2, T3> BuilderIn3<Q, T1, T2, T3> withCondition(Field<T1> field1, Field<T2> field2, Field<T3> field3);\n\n        <T1, T2, T3, T4> BuilderIn4<Q, T1, T2, T3, T4> withCondition(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4);\n\n        <T1, T2, T3, T4, T5> BuilderIn5<Q, T1, T2, T3, T4, T5> withCondition(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5);\n    }\n\n    public interface BuilderIn1<Q extends SelectFinalStep, T> {\n        QueryExtension<Q> in(Collection<T> values);\n    }\n\n    public interface BuilderIn2<Q extends SelectFinalStep, T1, T2> {\n        QueryExtension<Q> in(Collection<Tuple2<T1, T2>> values);\n    }\n\n    public interface BuilderIn3<Q extends SelectFinalStep, T1, T2, T3> {\n        QueryExtension<Q> in(Collection<Tuple3<T1, T2, T3>> values);\n    }\n\n    public interface BuilderIn4<Q extends SelectFinalStep, T1, T2, T3, T4> {\n        QueryExtension<Q> in(Collection<Tuple4<T1, T2, T3, T4>> values);\n    }\n\n    public interface BuilderIn5<Q extends SelectFinalStep, T1, T2, T3, T4, T5> {\n        QueryExtension<Q> in(Collection<Tuple5<T1, T2, T3, T4, T5>> values);\n    }\n\n    public interface QueryExtension<Q extends SelectFinalStep> extends AutoCloseable {\n        Q getQuery();\n\n        void close();\n    }\n\n    private static class QueryExtensionImpl<Q extends SelectFinalStep> implements QueryExtension<Q> {\n        private final DatabaseClient dbClient;\n        private final Q query;\n        private final List<FieldAndValues<?>> conditions;\n\n        QueryExtensionImpl(DatabaseClient dbClient, Q query, List<FieldAndValues<?>> conditions) {\n            this.dbClient = dbClient;\n            this.query = query;\n            this.conditions = conditions;\n        }\n\n        @Override\n        public Q getQuery() {\n            return query;\n        }\n\n        @Override\n        public void close() {\n            // No-op for Spanner, as there's no resource to explicitly close here\n        }\n\n        // This method executes the query with conditions against Spanner\n        void execute() {\n            try {\n                dbClient.readWriteTransaction()\n                        .run(transaction -> {\n                            Statement.Builder builder = Statement.newBuilder(query.getSQL());\n\n                            for (FieldAndValues<?> condition : conditions) {\n                                builder.append(\" AND \");\n                                appendCondition(transaction, builder, condition.getField(), condition.getValues());\n                            }\n\n                            Statement statement = builder.build();\n                            try (ResultSet resultSet = transaction.executeQuery(statement)) {\n                                while (resultSet.next()) {\n                                    // Process the result set if needed\n                                }\n                            }\n                            return null;\n                        });\n            } catch (Exception e) {\n                // Handle exceptions\n            }\n        }\n\n        // Append condition to the Spanner statement\n        private <T> void appendCondition(TransactionContext transaction, Statement.Builder builder, Field<T> field, Collection<T> values) {\n            builder.append(field.getName()).append(\" IN (\");\n            boolean first = true;\n            for (T value : values) {\n                if (!first) {\n                    builder.append(\", \");\n                }\n                builder.append(Value.create(value).toString());\n                first = false;\n            }\n            builder.append(\")\");\n        }\n    }\n\n    // Field and values holder, similar to FieldAndValues in original code\n    private static class FieldAndValues<T> {\n        private final Field<T> field;\n        private final Collection<T> values;\n\n        FieldAndValues(Field<T> field, Collection<T> values) {\n            this.field = field;\n            this.values = values;\n        }\n\n        public Field<T> getField() {\n            return field;\n        }\n\n        public Collection<T> getValues() {\n            return values;\n        }\n    }\n}\n"}
{"input_text": "convert following Java code from MySQL to Spanner \npackage com.kenshoo.pl.entity.mysql;\n\nimport com.google.common.base.Splitter;\nimport com.google.common.base.Throwables;\nimport com.kenshoo.pl.entity.spi.DeadlockDetector;\nimport org.jooq.lambda.Seq;\nimport java.sql.SQLException;\nimport static org.jooq.lambda.Seq.seq;\n\n\npublic class MySqlDeadlockDetector implements DeadlockDetector {\n\n    private String retryPatterns = \"lock wait timeout exceeded;deadlock\";\n\n    @Override\n    public boolean isDeadlock(Throwable e) {\n        Throwable rootCause = Throwables.getRootCause(e);\n        return rootCause instanceof SQLException\n                && rootCause.getMessage() != null\n                && deadlockStrings().anyMatch(rootCause.getMessage().toLowerCase()::contains);\n    }\n\n    private Seq<String> deadlockStrings() {\n        return seq(Splitter.on(\";\")\n                .trimResults()\n                .omitEmptyStrings()\n                .splitToList(retryPatterns));\n    }\n\n}\n", "output_text": "package com.kenshoo.pl.entity.mysql;\n\nimport com.google.common.base.Splitter;\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.ImmutableList;\nimport com.kenshoo.pl.entity.spi.DeadlockDetector;\nimport org.jooq.lambda.Seq;\n\nimport java.util.List;\n\npublic class SpannerDeadlockDetector implements DeadlockDetector {\n\n    private final List<String> retryPatterns = ImmutableList.of(\"Transaction aborted\", \"Aborted due to concurrent update\");\n\n    @Override\n    public boolean isDeadlock(Throwable e) {\n        Throwable rootCause = Throwables.getRootCause(e);\n        String rootMessage = rootCause.getMessage();\n        if (rootMessage != null) {\n            String lowerCaseMessage = rootMessage.toLowerCase();\n            return retryPatterns.stream().anyMatch(lowerCaseMessage::contains);\n        }\n        return false;\n    }\n\n}\n"}
{"input_text": "convert following Java code from MySQL to Spanner \npackage com.kenshoo.pl.data;\r\n\r\nimport com.kenshoo.jooq.DataTable;\r\nimport com.kenshoo.jooq.FieldAndValue;\r\nimport com.kenshoo.pl.data.CreateRecordCommand.OnDuplicateKey;\r\nimport org.jooq.*;\r\nimport org.jooq.impl.DSL;\r\nimport java.util.*;\r\nimport java.util.stream.IntStream;\r\nimport java.util.stream.Stream;\r\n\r\nimport static java.util.stream.Collectors.toList;\r\nimport static java.util.stream.Collectors.toSet;\r\nimport static org.jooq.lambda.Seq.seq;\r\n\r\npublic class CommandsExecutor {\r\n\r\n    final private DSLContext dslContext;\r\n\r\n    public CommandsExecutor(DSLContext dslContext) {\r\n        this.dslContext = dslContext;\r\n    }\r\n\r\n    public static CommandsExecutor of(DSLContext dslContext) {\r\n        return new CommandsExecutor(dslContext);\r\n    }\r\n\r\n    public AffectedRows executeInserts(final DataTable table, Collection<? extends CreateRecordCommand> commands) {\r\n        return executeCommands(commands, homogeneousCommands -> executeInsertCommands(table, homogeneousCommands, OnDuplicateKey.FAIL));\r\n    }\r\n\r\n    public AffectedRows executeInsertsOnDuplicateKeyIgnore(final DataTable table, Collection<? extends CreateRecordCommand> commands) {\r\n        return executeCommands(commands, homogeneousCommands -> executeInsertCommands(table, homogeneousCommands, OnDuplicateKey.IGNORE));\r\n    }\r\n\r\n    public AffectedRows executeInsertsOnDuplicateKeyUpdate(final DataTable table, Collection<? extends CreateRecordCommand> commands) {\r\n        return executeCommands(commands, homogeneousCommands -> executeInsertCommands(table, homogeneousCommands, OnDuplicateKey.UPDATE));\r\n    }\r\n\r\n    public AffectedRows executeUpdates(final DataTable table, Collection<? extends UpdateRecordCommand> commands) {\r\n        return executeCommands(commands, homogeneousCommands -> executeUpdateCommands(table, homogeneousCommands));\r\n    }\r\n\r\n    public AffectedRows executeDeletes(final DataTable table, Collection<? extends DeleteRecordCommand> commands) {\r\n        if (commands.isEmpty()) {\r\n            return AffectedRows.empty();\r\n        }\r\n        return executeDeleteCommands(table, commands);\r\n    }\r\n\r\n    private <C extends AbstractRecordCommand> AffectedRows executeCommands(Collection<? extends C> commands, HomogeneousChunkExecutor<C> homogeneousChunkExecutor) {\r\n        AffectedRows updated = AffectedRows.empty();\r\n        List<C> commandsLeft = new LinkedList<>(commands);\r\n        while (!commandsLeft.isEmpty()) {\r\n            C firstCommand = commandsLeft.remove(0);\r\n            List<C> commandsToExecute = new ArrayList<>(Collections.singletonList(firstCommand));\r\n            Set<String> firstCommandFields = getFieldsNames(firstCommand);\r\n            Iterator<C> iterator = commandsLeft.iterator();\r\n            while (iterator.hasNext()) {\r\n                C command = iterator.next();\r\n                if (getFieldsNames(command).equals(firstCommandFields)) {\r\n                    commandsToExecute.add(command);\r\n                    iterator.remove();\r\n                }\r\n            }\r\n            updated = updated.plus(homogeneousChunkExecutor.execute(commandsToExecute));\r\n        }\r\n        return updated;\r\n    }\r\n\r\n    private AffectedRows executeDeleteCommands(DataTable table, Collection<? extends DeleteRecordCommand> commandsToExecute) {\r\n        DeleteWhereStep<Record> delete = dslContext.delete(table);\r\n        Iterator<? extends DeleteRecordCommand> commandIt = commandsToExecute.iterator();\r\n        DeleteRecordCommand command = commandIt.next();\r\n        Condition condition = DSL.trueCondition();\r\n        TableField[] tableFields = command.getId().getTableFields();\r\n        for (TableField id : tableFields) {\r\n            //noinspection unchecked\r\n            condition = condition.and(id.eq((Object) null));\r\n        }\r\n        for (FieldAndValue<?> partitionFieldAndValue : table.getVirtualPartition()) {\r\n            //noinspection unchecked\r\n            condition = condition.and(((Field) partitionFieldAndValue.getField()).eq((Object) null));\r\n        }\r\n        delete.where(condition);\r\n\r\n        BatchBindStep batch = dslContext.batch(delete);\r\n        while (command != null) {\r\n            List<Object> values = Stream.concat(Stream.of(command.getId().getValues()),\r\n                    table.getVirtualPartition().stream().map(FieldAndValue::getValue)).collect(toList());\r\n            batch.bind(values.toArray());\r\n            command = commandIt.hasNext() ? commandIt.next() : null;\r\n        }\r\n        return AffectedRows.deleted(IntStream.of(batch.execute()).sum());\r\n    }\r\n\r\n    private AffectedRows executeUpdateCommands(DataTable table, List<? extends UpdateRecordCommand> commandsToExecute) {\r\n        UpdateSetFirstStep update1 = dslContext.update(table);\r\n        UpdateSetMoreStep update = null;\r\n        UpdateRecordCommand command1 = commandsToExecute.get(0);\r\n        if (!command1.getFields().findFirst().isPresent()) {\r\n            return AffectedRows.empty();\r\n        }\r\n        for (Field<?> field : seq(command1.getFields())) {\r\n            if (update != null) {\r\n                update = update.set(field, (Object) null);\r\n            } else {\r\n                update = update1.set(field, (Object) null);\r\n            }\r\n        }\r\n        assert update != null;\r\n        Condition condition = DSL.trueCondition();\r\n        TableField[] tableFields = command1.getId().getTableFields();\r\n        for (TableField id : tableFields) {\r\n            //noinspection unchecked\r\n            condition = condition.and(id.eq((Object) null));\r\n        }\r\n        for (FieldAndValue<?> partitionFieldAndValue : table.getVirtualPartition()) {\r\n            //noinspection unchecked\r\n            condition = condition.and(((Field) partitionFieldAndValue.getField()).eq((Object) null));\r\n        }\r\n        update.where(condition);\r\n\r\n        BatchBindStep batch = dslContext.batch(update);\r\n        for (UpdateRecordCommand command : commandsToExecute) {\r\n            List<Object> values = Stream.of(command.getValues(command1.getFields()),\r\n                    Stream.of(command.getId().getValues()),\r\n                    table.getVirtualPartition().stream().map(FieldAndValue::getValue)).flatMap(s -> s).collect(toList());\r\n            batch.bind(values.toArray());\r\n        }\r\n        int[] execute = batch.execute();\r\n        return AffectedRows.updated(IntStream.of(execute).sum());\r\n    }\r\n\r\n    private AffectedRows executeInsertCommands(DataTable table, List<? extends CreateRecordCommand> commandsToExecute, OnDuplicateKey onDuplicateKey) {\r\n\r\n        final Optional<GeneratedKeyRecorder> generatedKeyRecorder = Optional.ofNullable(table.getIdentity())\r\n                .map(identity -> new GeneratedKeyRecorder(identity.getField(), commandsToExecute.size()));\r\n\r\n        DSLContext dslContext = generatedKeyRecorder.map(g -> g.newRecordingJooq(this.dslContext)).orElse(this.dslContext);\r\n\r\n        CreateRecordCommand firstCommand = commandsToExecute.get(0);\r\n        Collection<Field<?>> fields = Stream.concat(firstCommand.getFields(), table.getVirtualPartition().stream().map(FieldAndValue::getField)).collect(toList());\r\n        InsertValuesStepN<Record> insertValuesStepN = dslContext.insertInto(table, fields).values(new Object[fields.size()]);\r\n        Insert insert = insertValuesStepN;\r\n        switch (onDuplicateKey) {\r\n            case IGNORE:\r\n                insert = insertValuesStepN.onDuplicateKeyIgnore();\r\n                break;\r\n            case UPDATE:\r\n                InsertOnDuplicateSetStep<Record> insertOnDuplicateSetStep = insertValuesStepN.onDuplicateKeyUpdate();\r\n                for (Field<?> field : seq(firstCommand.getFields())) {\r\n                    //noinspection unchecked\r\n                    insertOnDuplicateSetStep = insertOnDuplicateSetStep.set((Field) field, (Object) null);\r\n                }\r\n                insert = (Insert) insertOnDuplicateSetStep;\r\n                break;\r\n        }\r\n\r\n        BatchBindStep batch = dslContext.batch(insert);\r\n\r\n        for (AbstractRecordCommand command : commandsToExecute) {\r\n            List<Object> values = Stream.concat(command.getValues(firstCommand.getFields()), table.getVirtualPartition().stream().map(FieldAndValue::getValue)).collect(toList());\r\n            if (onDuplicateKey == OnDuplicateKey.UPDATE) {\r\n                values = Stream.concat(values.stream(), values.stream()).collect(toList());\r\n            }\r\n            batch.bind(values.toArray());\r\n        }\r\n        int[] result = batch.execute();\r\n        // See https://dev.mysql.com/doc/refman/5.7/en/mysql-affected-rows.html for explanation\r\n        // In case of regular INSERT (without IGNORE or ON DUPLICATE KEY UPDATE) the result is -2 for every inserted row\r\n        int inserted = (int) IntStream.of(result).filter(i -> i == 1 || i == -2).count();\r\n        int updated = (int) IntStream.of(result).filter(i -> i == 2).count();\r\n\r\n        generatedKeyRecorder\r\n                .map(GeneratedKeyRecorder::getGeneratedKeys)\r\n                .ifPresent(generatedKeys -> setIdsToCommands(table.getIdentity().getField(), commandsToExecute, generatedKeys));\r\n\r\n        return AffectedRows.insertedAndUpdated(inserted, updated);\r\n    }\r\n\r\n    private void setIdsToCommands(Field idField, List<? extends CreateRecordCommand> commandsToExecute, List<Object> generatedKeys) {\r\n        seq(commandsToExecute).zip(generatedKeys).forEach(pair -> pair.v1.set(idField, pair.v2));\r\n    }\r\n\r\n    private Set<String> getFieldsNames(AbstractRecordCommand command) {\r\n        return command.getFields().map(Field::getName).collect(toSet());\r\n    }\r\n\r\n    @FunctionalInterface\r\n    interface HomogeneousChunkExecutor<C extends AbstractRecordCommand> {\r\n        AffectedRows execute(List<C> commands);\r\n    }\r\n\r\n}\r\n\r", "output_text": "package com.kenshoo.pl.data;\n\nimport com.google.cloud.spanner.*;\nimport com.google.cloud.spanner.Statement.Builder;\nimport com.google.cloud.spanner.TransactionContext;\nimport com.google.cloud.spanner.TransactionRunner;\nimport com.kenshoo.jooq.DataTable;\nimport com.kenshoo.jooq.FieldAndValue;\nimport com.kenshoo.pl.data.CreateRecordCommand;\nimport com.kenshoo.pl.data.DeleteRecordCommand;\nimport com.kenshoo.pl.data.UpdateRecordCommand;\nimport org.jooq.Field;\nimport org.jooq.lambda.Seq;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\n\npublic class SpannerCommandsExecutor {\n\n    private final DatabaseClient dbClient;\n\n    public SpannerCommandsExecutor(DatabaseClient dbClient) {\n        this.dbClient = dbClient;\n    }\n\n    public static SpannerCommandsExecutor of(DatabaseClient dbClient) {\n        return new SpannerCommandsExecutor(dbClient);\n    }\n\n    public AffectedRows executeInserts(DataTable table, Collection<? extends CreateRecordCommand> commands) {\n        return executeCommands(commands, this::executeInsertCommands);\n    }\n\n    public AffectedRows executeInsertsOnDuplicateKeyIgnore(DataTable table, Collection<? extends CreateRecordCommand> commands) {\n        // Spanner does not have direct support for ON DUPLICATE KEY IGNORE\n        return executeInserts(table, commands);\n    }\n\n    public AffectedRows executeInsertsOnDuplicateKeyUpdate(DataTable table, Collection<? extends CreateRecordCommand> commands) {\n        // Spanner does not have direct support for ON DUPLICATE KEY UPDATE\n        return executeInserts(table, commands);\n    }\n\n    public AffectedRows executeUpdates(DataTable table, Collection<? extends UpdateRecordCommand> commands) {\n        return executeCommands(commands, this::executeUpdateCommands);\n    }\n\n    public AffectedRows executeDeletes(DataTable table, Collection<? extends DeleteRecordCommand> commands) {\n        return executeCommands(commands, this::executeDeleteCommands);\n    }\n\n    private <C extends AbstractRecordCommand> AffectedRows executeCommands(Collection<? extends C> commands, HomogeneousChunkExecutor<C> homogeneousChunkExecutor) {\n        AffectedRows updated = AffectedRows.empty();\n        List<C> commandsLeft = new LinkedList<>(commands);\n        while (!commandsLeft.isEmpty()) {\n            C firstCommand = commandsLeft.remove(0);\n            List<C> commandsToExecute = new ArrayList<>(Collections.singletonList(firstCommand));\n            Set<String> firstCommandFields = getFieldsNames(firstCommand);\n            Iterator<C> iterator = commandsLeft.iterator();\n            while (iterator.hasNext()) {\n                C command = iterator.next();\n                if (getFieldsNames(command).equals(firstCommandFields)) {\n                    commandsToExecute.add(command);\n                    iterator.remove();\n                }\n            }\n            updated = updated.plus(homogeneousChunkExecutor.execute(commandsToExecute));\n        }\n        return updated;\n    }\n\n    private AffectedRows executeDeleteCommands(Collection<? extends DeleteRecordCommand> commandsToExecute) {\n        int deletedRows = 0;\n        for (DeleteRecordCommand command : commandsToExecute) {\n            Key.Builder keyBuilder = Key.newBuilder();\n            command.getId().getValues().forEach(keyBuilder::appendObject);\n            Key key = keyBuilder.build();\n\n            // Create a delete statement\n            Statement statement = Statement.newBuilder(\n                    \"DELETE FROM \" + command.getId().getTableName() + \" WHERE \" + key.getSql()).build();\n\n            // Execute the delete statement\n            try {\n                dbClient.executePartitionedUpdate(statement);\n                deletedRows++;\n            } catch (SpannerException e) {\n                // Handle exception appropriately\n            }\n        }\n        return AffectedRows.deleted(deletedRows);\n    }\n\n    private AffectedRows executeUpdateCommands(Collection<? extends UpdateRecordCommand> commandsToExecute) {\n        int updatedRows = 0;\n        for (UpdateRecordCommand command : commandsToExecute) {\n            Key.Builder keyBuilder = Key.newBuilder();\n            command.getId().getValues().forEach(keyBuilder::appendObject);\n            Key key = keyBuilder.build();\n\n            // Create an update statement\n            Builder statementBuilder = Statement.newBuilder(\n                    \"UPDATE \" + command.getId().getTableName() + \" SET \");\n            boolean firstField = true;\n            for (FieldAndValue<?> fieldAndValue : command.getFields()) {\n                if (!firstField) {\n                    statementBuilder.append(\", \");\n                }\n                statementBuilder.append(fieldAndValue.getField().getName() + \" = ?\");\n                firstField = false;\n            }\n            statementBuilder.append(\" WHERE \" + key.getSql());\n\n            Statement statement = statementBuilder.build();\n            List<Value> params = command.getValues().stream()\n                    .map(ValueBinder::bind)\n                    .collect(Collectors.toList());\n\n            // Execute the update statement\n            try {\n                dbClient.readWriteTransaction()\n                        .run(transaction -> {\n                            long rowCount = transaction.executeUpdate(statement.bind(params.toArray(new Value[0])));\n                            updatedRows += rowCount;\n                            return null;\n                        });\n            } catch (SpannerException e) {\n                // Handle exception appropriately\n            }\n        }\n        return AffectedRows.updated(updatedRows);\n    }\n\n    private AffectedRows executeInsertCommands(Collection<? extends CreateRecordCommand> commandsToExecute) {\n        int insertedRows = 0;\n        for (CreateRecordCommand command : commandsToExecute) {\n            List<Column> columns = new ArrayList<>();\n            List<Value> values = new ArrayList<>();\n            for (FieldAndValue<?> fieldAndValue : command.getFields()) {\n                columns.add(Column.of(fieldAndValue.getField().getName(), fieldAndValue.getValue()));\n                values.add(ValueBinder.bind(fieldAndValue.getValue()));\n            }\n            Mutation.WriteBuilder writeBuilder = Mutation.newInsertBuilder(command.getId().getTableName())\n                    .set(columns.toArray(new Column[0]));\n\n            // Execute the insert mutation\n            try {\n                dbClient.readWriteTransaction()\n                        .run(transaction -> {\n                            transaction.buffer(writeBuilder.build());\n                            insertedRows++;\n                            return null;\n                        });\n            } catch (SpannerException e) {\n                // Handle exception appropriately\n            }\n        }\n        return AffectedRows.inserted(insertedRows);\n    }\n\n    private Set<String> getFieldsNames(AbstractRecordCommand command) {\n        return command.getFields().stream().map(Field::getName).collect(Collectors.toSet());\n    }\n\n    @FunctionalInterface\n    interface HomogeneousChunkExecutor<C extends AbstractRecordCommand> {\n        AffectedRows execute(Collection<? extends C> commands);\n    }\n}\n"}
{"input_text": "convert following Java code from MySQL to Spanner \npackage com.kenshoo.pl.entity;\r\n\r\nimport com.google.common.base.Throwables;\r\nimport com.google.common.collect.ImmutableList;\r\nimport com.kenshoo.jooq.AbstractDataTable;\r\nimport com.kenshoo.jooq.DataTable;\r\nimport com.kenshoo.jooq.DataTableUtils;\r\nimport com.kenshoo.jooq.TestJooqConfig;\r\nimport com.kenshoo.pl.entity.mysql.MySqlDeadlockDetector;\r\nimport com.kenshoo.pl.entity.spi.OutputGenerator;\r\nimport org.apache.commons.lang3.RandomStringUtils;\r\nimport org.jooq.DSLContext;\r\nimport org.jooq.Record;\r\nimport org.jooq.TableField;\r\nimport org.jooq.impl.SQLDataType;\r\nimport org.junit.*;\r\n\r\nimport java.sql.SQLException;\r\nimport java.util.Collection;\r\nimport java.util.concurrent.CyclicBarrier;\r\nimport java.util.concurrent.ExecutorService;\r\nimport java.util.concurrent.Executors;\r\nimport java.util.concurrent.TimeUnit;\r\nimport java.util.concurrent.atomic.AtomicReference;\r\nimport java.util.stream.Stream;\r\n\r\nimport static org.hamcrest.Matchers.instanceOf;\r\nimport static org.hamcrest.Matchers.is;\r\nimport static org.junit.Assert.*;\r\n\r\npublic class DeadlockTest {\r\n\r\n    private static final int ID = 1;\r\n\r\n    private static final Object[][] DATA = {\r\n            {ID, \"Alpha\"},\r\n    };\r\n\r\n    private DSLContext dslContext = TestJooqConfig.create();\r\n\r\n    private PersistenceLayer<TestEntityType> persistenceLayer;\r\n\r\n    private static TestTable table1;\r\n    private static TestTable table2;\r\n    private static TestEntityType entityType;\r\n    private static DSLContext staticDSLContext;\r\n\r\n    @AfterClass\r\n    public static void dropTables() {\r\n        staticDSLContext.dropTableIfExists(table1).execute();\r\n        staticDSLContext.dropTableIfExists(table2).execute();\r\n    }\r\n\r\n    @Before\r\n    public void setup() {\r\n\r\n        persistenceLayer = new PersistenceLayer<>(dslContext);\r\n\r\n        if (table1 == null) {\r\n            String tableName1 = RandomStringUtils.randomAlphanumeric(15);\r\n            table1 = new TestTable(tableName1);\r\n            DataTableUtils.createTable(dslContext, table1);\r\n\r\n            String tableName2 = RandomStringUtils.randomAlphanumeric(15);\r\n            table2 = new TestTable(tableName2);\r\n            DataTableUtils.createTable(dslContext, table2);\r\n\r\n            entityType = new TestEntityType();\r\n\r\n            staticDSLContext = dslContext;\r\n        }\r\n        DataTableUtils.populateTable(dslContext, table1, DATA);\r\n        DataTableUtils.populateTable(dslContext, table2, DATA);\r\n\r\n    }\r\n\r\n    @After\r\n    public void clearTables() {\r\n        dslContext.deleteFrom(table1).execute();\r\n        dslContext.deleteFrom(table2).execute();\r\n    }\r\n\r\n    @Test\r\n    public void deadlockWithNoRetries() throws InterruptedException {\r\n        DeadlockRetryer dataBaseRetryer = createDataBaseRetryer(1);\r\n        PLContext plContext = new PLContext.Builder(dslContext).withRetryer(dataBaseRetryer).build();\r\n        AtomicReference<Exception> exception = runTwoLockingThreads(plContext);\r\n        assertNotNull(exception.get());\r\n        assertThat(Throwables.getRootCause(exception.get()), is(instanceOf(SQLException.class)));\r\n    }\r\n\r\n    @Test\r\n    public void noDeadlockWithRetries() throws InterruptedException {\r\n        DeadlockRetryer dataBaseRetryer = createDataBaseRetryer(3);\r\n        PLContext plContext = new PLContext.Builder(dslContext).withRetryer(dataBaseRetryer).build();\r\n        AtomicReference<Exception> exception = runTwoLockingThreads(plContext);\r\n        assertNull(exception.get());\r\n    }\r\n\r\n    private AtomicReference<Exception> runTwoLockingThreads(PLContext plContext) throws InterruptedException {\r\n        ExecutorService executorService = Executors.newFixedThreadPool(2);\r\n        CyclicBarrier barrier = new CyclicBarrier(2);\r\n        AtomicReference<Exception> exception = new AtomicReference<>();\r\n        OutputGenerator<TestEntityType> outputGenerator1 = new DeadlockOutputGenerator(table1, table2, barrier);\r\n        ChangeFlowConfig<TestEntityType> flowConfig1 = ChangeFlowConfigBuilderFactory.newInstance(plContext, entityType).withoutOutputGenerators().withOutputGenerator(outputGenerator1).build();\r\n        executorService.submit(() -> {\r\n            try {\r\n                persistenceLayer.update(ImmutableList.of(new UpdateEntityCommand<>(entityType, new TestEntityType.Key(ID))), flowConfig1);\r\n                return;\r\n            } catch (Exception e) {\r\n                exception.set(e);\r\n            }\r\n        });\r\n        OutputGenerator<TestEntityType> outputGenerator2 = new DeadlockOutputGenerator(table2, table1, barrier);\r\n        ChangeFlowConfig<TestEntityType> flowConfig2 = ChangeFlowConfigBuilderFactory.newInstance(plContext, entityType).withoutOutputGenerators().withOutputGenerator(outputGenerator2).build();\r\n        executorService.submit(() -> {\r\n            try {\r\n                persistenceLayer.update(ImmutableList.of(new UpdateEntityCommand<>(entityType, new TestEntityType.Key(ID))), flowConfig2);\r\n                return;\r\n            } catch (Exception e) {\r\n                exception.set(e);\r\n            }\r\n        });\r\n        executorService.shutdown();\r\n        executorService.awaitTermination(1, TimeUnit.SECONDS);\r\n        return exception;\r\n    }\r\n\r\n    private DeadlockRetryer createDataBaseRetryer(int maxDeadlockRetries) {\r\n        DeadlockRetryer dataBaseRetryer = new DeadlockRetryer(new MySqlDeadlockDetector(), () -> false);\r\n        dataBaseRetryer.setMaxDeadlockRetries(maxDeadlockRetries);\r\n        dataBaseRetryer.setFirstSleepBetweenRetriesMillis(50);\r\n        return dataBaseRetryer;\r\n    }\r\n\r\n    private static class TestTable extends AbstractDataTable<TestTable> {\r\n\r\n        private final TableField<Record, Integer> id = createPKField(\"id\", SQLDataType.INTEGER);\r\n        private final TableField<Record, String> field = createField(\"field\", SQLDataType.VARCHAR.length(50));\r\n\r\n        public TestTable(String name) {\r\n            super(name);\r\n        }\r\n\r\n        public TestTable(TestTable aliased, String alias) {\r\n            super(aliased, alias);\r\n        }\r\n\r\n        @Override\r\n        public TestTable as(String alias) {\r\n            return new TestTable(this, alias);\r\n        }\r\n    }\r\n\r\n\r\n    public static class TestEntityType extends AbstractEntityType<TestEntityType> {\r\n\r\n        public static final TestEntityType INSTANCE = new TestEntityType();\r\n\r\n        public static final EntityField<TestEntityType, Integer> ID = INSTANCE.field(table1.id);\r\n        public static final EntityField<TestEntityType, String> FIELD = INSTANCE.field(table1.field);\r\n\r\n        protected TestEntityType() {\r\n            super(\"test\");\r\n        }\r\n\r\n        @Override\r\n        public DataTable getPrimaryTable() {\r\n            return table1;\r\n        }\r\n\r\n        public static class Key extends SingleUniqueKeyValue<TestEntityType, Integer> {\r\n            public static final SingleUniqueKey<TestEntityType, Integer> DEFINITION = new SingleUniqueKey<TestEntityType, Integer>(ID) {\r\n                @Override\r\n                protected SingleUniqueKeyValue<TestEntityType, Integer> createValue(Integer value) {\r\n                    return new Key(value);\r\n                }\r\n            };\r\n\r\n            public Key(int val) {\r\n                super(DEFINITION, val);\r\n            }\r\n        }\r\n    }\r\n\r\n    private class DeadlockOutputGenerator implements OutputGenerator<TestEntityType> {\r\n\r\n        private final TestTable table1;\r\n        private final TestTable table2;\r\n        private final CyclicBarrier barrier;\r\n        private boolean waitForBarrier = true;\r\n\r\n        public DeadlockOutputGenerator(TestTable table1, TestTable table2, CyclicBarrier barrier) {\r\n            this.table1 = table1;\r\n            this.table2 = table2;\r\n            this.barrier = barrier;\r\n        }\r\n\r\n        @Override\r\n        public void generate(Collection<? extends EntityChange<TestEntityType>> entityChanges, ChangeOperation changeOperation, ChangeContext changeContext) {\r\n            dslContext.update(table1).set(table1.field, \"test\").where(table1.id.eq(1)).execute();\r\n            try {\r\n                if (waitForBarrier) {\r\n                    waitForBarrier = false;\r\n                    barrier.await();\r\n                }\r\n            } catch (Exception e) {\r\n                throw Throwables.propagate(e);\r\n            }\r\n            dslContext.update(table2).set(table2.field, \"test\").where(table2.id.eq(1)).execute();\r\n        }\r\n\r\n        @Override\r\n        public Stream<? extends EntityField<?, ?>> requiredFields(Collection<? extends EntityField<TestEntityType, ?>> fieldsToUpdate, ChangeOperation changeOperation) {\r\n            return Stream.empty();\r\n        }\r\n    }\r\n}\r", "output_text": "package com.kenshoo.pl.entity;\n\nimport com.google.cloud.spanner.*;\nimport com.google.cloud.spanner.Statement.Builder;\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.ImmutableList;\nimport com.kenshoo.jooq.AbstractDataTable;\nimport com.kenshoo.jooq.DataTable;\nimport com.kenshoo.jooq.DataTableUtils;\nimport com.kenshoo.pl.entity.AbstractEntityType;\nimport com.kenshoo.pl.entity.ChangeFlowConfig;\nimport com.kenshoo.pl.entity.ChangeFlowConfigBuilderFactory;\nimport com.kenshoo.pl.entity.ChangeOperation;\nimport com.kenshoo.pl.entity.EntityChange;\nimport com.kenshoo.pl.entity.EntityField;\nimport com.kenshoo.pl.entity.PersistenceLayer;\nimport com.kenshoo.pl.entity.PLContext;\nimport com.kenshoo.pl.entity.SingleUniqueKey;\nimport com.kenshoo.pl.entity.SingleUniqueKeyValue;\nimport com.kenshoo.pl.entity.UpdateEntityCommand;\nimport com.kenshoo.pl.entity.mysql.MySqlDeadlockDetector;\nimport com.kenshoo.pl.entity.spi.DeadlockRetryer;\nimport com.kenshoo.pl.entity.spi.OutputGenerator;\nimport org.apache.commons.lang3.RandomStringUtils;\nimport org.jooq.DSLContext;\nimport org.jooq.Record;\nimport org.jooq.TableField;\nimport org.jooq.impl.SQLDataType;\nimport org.junit.*;\n\nimport java.util.Collection;\nimport java.util.concurrent.*;\n\nimport static org.hamcrest.Matchers.instanceOf;\nimport static org.hamcrest.Matchers.is;\nimport static org.junit.Assert.*;\n\npublic class DeadlockTest {\n\n    private static final int ID = 1;\n\n    private static final Object[][] DATA = {\n            {ID, \"Alpha\"},\n    };\n\n    private DatabaseClient dbClient;\n\n    private PersistenceLayer<TestEntityType> persistenceLayer;\n\n    private static TestTable table1;\n    private static TestTable table2;\n    private static TestEntityType entityType;\n\n    @BeforeClass\n    public static void setupClass() {\n        // Initialize Spanner tables\n        String tableName1 = RandomStringUtils.randomAlphanumeric(15);\n        table1 = new TestTable(tableName1);\n\n        String tableName2 = RandomStringUtils.randomAlphanumeric(15);\n        table2 = new TestTable(tableName2);\n\n        // Create Spanner tables\n        DataTableUtils.createTable(table1);\n        DataTableUtils.createTable(table2);\n\n        entityType = new TestEntityType();\n    }\n\n    @Before\n    public void setup() {\n        // Initialize Spanner database client\n        dbClient = SpannerClient.getDatabaseClient();\n        persistenceLayer = new PersistenceLayer<>(dbClient);\n\n        // Populate Spanner tables with test data\n        DataTableUtils.populateTable(table1, DATA);\n        DataTableUtils.populateTable(table2, DATA);\n    }\n\n    @After\n    public void clearTables() {\n        // Clear Spanner tables after each test\n        dbClient.readWriteTransaction().run(transaction -> {\n            transaction.executeUpdate(Statement.of(\"DELETE FROM \" + table1.getName()));\n            transaction.executeUpdate(Statement.of(\"DELETE FROM \" + table2.getName()));\n            return null;\n        });\n    }\n\n    @Test\n    public void deadlockWithNoRetries() throws InterruptedException {\n        DeadlockRetryer dataBaseRetryer = createDataBaseRetryer(1);\n        PLContext plContext = new PLContext.Builder(dbClient).withRetryer(dataBaseRetryer).build();\n        AtomicReference<Exception> exception = runTwoLockingThreads(plContext);\n        assertNotNull(exception.get());\n        assertThat(Throwables.getRootCause(exception.get()), is(instanceOf(AbortedException.class)));\n    }\n\n    @Test\n    public void noDeadlockWithRetries() throws InterruptedException {\n        DeadlockRetryer dataBaseRetryer = createDataBaseRetryer(3);\n        PLContext plContext = new PLContext.Builder(dbClient).withRetryer(dataBaseRetryer).build();\n        AtomicReference<Exception> exception = runTwoLockingThreads(plContext);\n        assertNull(exception.get());\n    }\n\n    private AtomicReference<Exception> runTwoLockingThreads(PLContext plContext) throws InterruptedException {\n        ExecutorService executorService = Executors.newFixedThreadPool(2);\n        CyclicBarrier barrier = new CyclicBarrier(2);\n        AtomicReference<Exception> exception = new AtomicReference<>();\n        OutputGenerator<TestEntityType> outputGenerator1 = new DeadlockOutputGenerator(table1, table2, barrier);\n        ChangeFlowConfig<TestEntityType> flowConfig1 = ChangeFlowConfigBuilderFactory.newInstance(plContext, entityType).withoutOutputGenerators().withOutputGenerator(outputGenerator1).build();\n        executorService.submit(() -> {\n            try {\n                persistenceLayer.update(ImmutableList.of(new UpdateEntityCommand<>(entityType, new TestEntityType.Key(ID))), flowConfig1);\n            } catch (Exception e) {\n                exception.set(e);\n            }\n        });\n        OutputGenerator<TestEntityType> outputGenerator2 = new DeadlockOutputGenerator(table2, table1, barrier);\n        ChangeFlowConfig<TestEntityType> flowConfig2 = ChangeFlowConfigBuilderFactory.newInstance(plContext, entityType).withoutOutputGenerators().withOutputGenerator(outputGenerator2).build();\n        executorService.submit(() -> {\n            try {\n                persistenceLayer.update(ImmutableList.of(new UpdateEntityCommand<>(entityType, new TestEntityType.Key(ID))), flowConfig2);\n            } catch (Exception e) {\n                exception.set(e);\n            }\n        });\n        executorService.shutdown();\n        executorService.awaitTermination(1, TimeUnit.SECONDS);\n        return exception;\n    }\n\n    private DeadlockRetryer createDataBaseRetryer(int maxDeadlockRetries) {\n        DeadlockRetryer dataBaseRetryer = new DeadlockRetryer(new MySqlDeadlockDetector(), () -> false);\n        dataBaseRetryer.setMaxDeadlockRetries(maxDeadlockRetries);\n        dataBaseRetryer.setFirstSleepBetweenRetriesMillis(50);\n        return dataBaseRetryer;\n    }\n\n    private static class TestTable extends AbstractDataTable<TestTable> {\n\n        private final TableField<Record, Integer> id = createPKField(\"id\", SQLDataType.INTEGER);\n        private final TableField<Record, String> field = createField(\"field\", SQLDataType.STRING);\n\n        public TestTable(String name) {\n            super(name);\n        }\n\n        @Override\n        public TestTable as(String alias) {\n            return new TestTable(this, alias);\n        }\n    }\n\n    public static class TestEntityType extends AbstractEntityType<TestEntityType> {\n\n        public static final TestEntityType INSTANCE = new TestEntityType();\n\n        public static final EntityField<TestEntityType, Integer> ID = INSTANCE.field(table1.id);\n        public static final EntityField<TestEntityType, String> FIELD = INSTANCE.field(table1.field);\n\n        protected TestEntityType() {\n            super(\"test\");\n        }\n\n        @Override\n        public DataTable getPrimaryTable() {\n            return table1;\n        }\n\n        public static class Key extends SingleUniqueKeyValue<TestEntityType, Integer> {\n            public static final SingleUniqueKey<TestEntityType, Integer> DEFINITION = new SingleUniqueKey<TestEntityType, Integer>(ID) {\n                @Override\n                protected SingleUniqueKeyValue<TestEntityType, Integer> createValue(Integer value) {\n                    return new Key(value);\n                }\n            };\n\n            public Key(int val) {\n                super(DEFINITION, val);\n            }\n        }\n    }\n\n    private class DeadlockOutputGenerator implements OutputGenerator<TestEntityType> {\n\n        private final TestTable table1;\n        private final TestTable table2;\n        private final CyclicBarrier barrier;\n        private boolean waitForBarrier = true;\n\n        public DeadlockOutputGenerator(TestTable table1, TestTable table2, CyclicBarrier barrier) {\n            this.table1 = table1;\n            this.table2 = table2;\n            this.barrier = barrier;\n        }\n\n        @Override\n        public void generate(Collection<? extends EntityChange<TestEntityType>> entityChanges, ChangeOperation changeOperation, ChangeContext changeContext) {\n            dbClient.readWriteTransaction().run(transaction -> {\n                transaction.executeUpdate(Statement.of(\"UPDATE \" + table1.getName() + \" SET field = 'test' WHERE id = 1\"));\n                try {\n                    if (waitForBarrier) {\n                        waitForBarrier = false;\n                        barrier.await();\n                    }\n                } catch (Exception e) {\n                    throw Throwables.propagate(e);\n                }\n                transaction.executeUpdate(Statement.of(\"UPDATE \" + table2.getName() + \" SET field = 'test' WHERE id = 1\"));\n                return null;\n            });\n        }\n\n        @Override\n        public Stream<? extends EntityField<?, ?>> requiredFields(Collection<? extends EntityField<TestEntityType, ?>> fieldsToUpdate, ChangeOperation changeOperation) {\n            return Stream.empty();\n        }\n    }\n}\n"}
