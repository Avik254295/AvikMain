# Copyright 2024 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Use Generative AI to supplement Airflow DAGs with doc_md values.
"""

import os
import logging
import argparse

import ast

from vertexai.generative_models import (
    GenerativeModel,
)

logging.basicConfig(level=logging.INFO)


def insert_descriptions(src_dir, tgt_dir):
    """
    Loop though a DAG folder. Use Google Gemini Pro model to generate descriptions in markdown.
    Insert the markdown into doc_md attribute of each DAG object and write to new DAG files in a
    target directory.
    """
    model = GenerativeModel("gemini-1.0-pro")

    for file in os.listdir(src_dir):  # pylint: disable=too-many-nested-blocks
        if ".py" in file:
            file_path = src_dir + file
            logging.info("Generating documentation for: %s", file_path)

            response = model.generate_content(
                [
                    "You're a Senior Data Engineer and an Apache Airflow expert.  Create a detailed markdown description of the following Airflow DAG and what it does:", #pylint: disable=line-too-long
                    open(file_path).read(),
                ]
            )

            desc = """
{description}

---

*Generated by* 

<img src="https://upload.wikimedia.org/wikipedia/commons/8/8a/Google_Gemini_logo.svg" alt="Google Gemini" width="85"/>
        """.format(
                description=response.text
            )
            desc = desc.replace("{", "")
            desc = desc.replace("}", "")

            tree = ast.parse(open(file_path).read())

            for node in ast.walk(tree):
                if isinstance(node, ast.Call):
                    if (
                        isinstance(node.func, ast.Attribute) and node.func.attr == "DAG"
                    ) or (isinstance(node.func, ast.Name) and node.func.id == "DAG"):
                        found = False
                        for keyword in node.keywords:
                            if keyword.arg == "doc_md":
                                keyword.value.value = desc
                                found = True
                                break
                        if not found:
                            new_keyword = ast.keyword(
                                arg="doc_md", value=ast.Constant(value=desc)
                            )
                            node.keywords.append(new_keyword)

                modified_code = ast.unparse(tree)

                filename = os.path.split(file_path)[1]

                with open(tgt_dir + filename, "w") as file:
                    file.write(modified_code)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Supplement DAGs with doc_md values.")
    parser.add_argument(
        "--src", type=str, help="The source dir containing existing airflow DAGs"
    )
    parser.add_argument(
        "--tgt", type=str, help="The target dir for newly documented airflow DAGs"
    )

    args = parser.parse_args()
    insert_descriptions(args.src, args.tgt)
