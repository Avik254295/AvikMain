# F5map

This is a single-purpose command line utility to parse F5 configuration files
into JSON for further manipulation and discovery. Please forgive the use of
Ruby.

# Goal

The goal of this tool is to ease the task of identifying load balancer
functionality to determine GCP ILB and GLB requirements.  The overall process is
to parse F5 configuration data from rancid and transform the data into a CSV
file suitable for analysis in Google Sheets.

# Input data

## F5 RANCID Config

This is the configuration file generated by [rancid][rancid].  In the field, the
customer provided output from rancid to analyze their F5 iRules programmatically.

## Example Output

The `f5 map` command implements the main behavior of creating useable output.

```json
[
  {
    "virtual": "DMZ",
    "pool": false,
    "rules": [
      "WEST-APP1-SNAT_Internet",
      "WEST-APP2-SNAT_Internet"
    ]
  },
  {
    "virtual": "app1-web_443",
    "pool": "app1_web_https",
    "rules": [
      "Throttle",
      "SecureHTTPOnlyFlag"
    ]
  },
  {
    "virtual": "app1-web_80",
    "pool": "app1_web_http",
    "rules": [
      "X-Forwarded-For"
    ]
  }
]
```

# Usage

## Installation

Pre-requisites:

 1. Modern ruby in the path.  (Developed with 2.5.1, any 2.x should be fine.)
 2. Bundler installed. (`sudo gem install bundler`)
 3. `jq` in the path (`brew install jq` using [Homebrew](https://brew.sh/) or
     install a pre-built self-contained binary from [Download
     jq](https://stedolan.github.io/jq/download/))

With these pre-requisites the `f5` utility may be run from the command line or
a CI system without installing anything else into the system paths.  All
dependencies are intended to be self-contained in the workspace directory.

### bundle install

```
bundle install --path .bundle/gems/
Fetching gem metadata from https://rubygems.org/........
...
Bundle complete! 5 Gemfile dependencies, 19 gems now installed.
Bundled gems are installed into `./.bundle/gems`
```

## Commands

### f5 --help

```
bundle exec f5 --help
usage: f5 [GLOBAL OPTIONS] SUBCOMMAND [ARGS]
Sub Commands:

  irules    Output all irule names (ltm rule config objects).
  pools     Output all pool names (ltm pool config objects).
  virtuals  Output all virtual servers (ltm virtual config objects).
  map       Output a list of all virtual servers including their configured
            target pool and their bound rules.

Global options: (Note, command line arguments supersede ENV vars in {}'s)
  -i, --input=<s>              F5 config file path to load or STDIN {INPUT} (default: f5.conf)
  -f, --format=<s>             Format, e.g. json, yaml {FORMAT} (default: json)
  -l, --logto=<s>              Log file to write to or keywords STDOUT, STDERR {LOGTO} (default: STDERR)
  -s, --syslog, --no-syslog    Log to syslog (default: true)
  -v, --verbose                Set log level to INFO
  -d, --debug                  Set log level to DEBUG
  -e, --version                Print version and exit
  -h, --help                   Show this message
```

## f5 map

The f5 map command is responsible for parsing the F5 configuration and
returning structured data.

### Store the output json

Store the output to iteratively explore using `jq`.  Pre-generated output files
are included in [spec/fixtures/][fixtures].

```bash
bundle exec f5 --input f5rancid.conf map > f5data.json
```

### Print out F5 iRules

The `f5 print-irule` command is intended to print out the code of a named
iRule.  This is useful to produce Markdown text files which may then be filled
in with a natural language description of the iRule behavior.

#### Print a single iRule

```
bundle exec f5 --input f5rancid.conf print-irule --rule myirule
```

#### Generate markdown files for all iRules

This example creates a markdown file describing every iRule currently active in
a Virtual Server of the external load balancer. This builds on the output of the
`f5 map` subcommand.  `xargs` provides concurrent execution.  xargs replaces `%`
with the irule name for each invocation of the command.

Adjust accordingly to process the internal F5 config instead of the external.

```bash
jq -c '.[].rules[]' f5data.json \
  | jq -rs 'unique | .[]' \
  | xargs -P8 -I% -n1 bundle exec f5 \
      --format markdown \
      --input f5rancid.conf \
      --verbose \
      print-irule \
      --rule % --output rules/%.markdown
```

Output:

```
Wrote output to rules/SomeRule.markdown
Wrote output to rules/AnotherRule.markdown
...
```

# Filtering with `jq`

## Produce one dictionary for each rule in a virtual server

```bash
jq -c '.[] | {virtual, pool, vip, destination, rule: .rules[]}' f5data.json
```

Output (truncated example)

```json
{"virtual":"app1_80","pool":"app1_http","vip":"app1","destination":"1.2.3.4:http","rule":"X-Forwarded-For"}
{"virtual":"app1_443","pool":"app1_https","vip":"app","destination":"1.2.4.5:https","rule":"X-Forwarded-For"}
```

## Produce CSV output

`jq` has a `@csv` filter to produce well formed CSV output.  This is useful to
load data into a spreadsheet for further processing.  Reference: [How to
convert arbirtrary simple JSON to CSV using
jq?](https://stackoverflow.com/questions/32960857/how-to-convert-arbirtrary-simple-json-to-csv-using-jq)

```
jq -c '.[] | {virtual, pool, vip, destination, rule: .rules[], persist: .persist[0]}' f5data.json \
  | jq -rs '(map(keys) | add | unique) as $cols
            | map(. as $row | $cols | map($row[.])) as $rows
            | $cols, $rows[]
            | @csv'
```

Loaded into Google Sheets, a clickable URL to the iRule code may be constructed
with a formula like:

```
=HYPERLINK(CONCATENATE("https://gitlab.example.com/someuser/f5map/blob/master/rules/",C2,".markdown"),C2)
```

## List all currently active iRules

Using jq, list all currently active iRules as defined by being configured in a
virtual server.

This command:

 1. Extracts each rule into a single array (`.[].rules`)
 2. Flattens out the array (`[]`)
 3. Slurps all entries into an array (`jq -s`)
 4. De-duplicates the list of rules (`unique | .[]`)
 5. Prints each rule using raw text output instead of JSON (`jq -r`)

```
jq -c '.[].rules[]' f5data.json | jq -rs 'unique | .[]'
```

For the load balancer, the list of rules active in configured virtual server
blocks are the output:

```
SomeRule
AnotherRule
...
```

## Filter out common iRules

Filter out virtual server iRule entries starting with e.g. `X-Forwarded-For_`.
This is useful to remove common elements.  Note the use of `not` at the end of
the filter.

```bash
jq -c '.[]
  | {virtual, pool, vip, destination, rule: .rules[]}
  | select(.rule|startswith("X-Forwarded-For")|not)' \
  f5data.json
```

## Filter out multiple common iRules

Focus in on application specific iRules by filtering out multiple common
iRules.  Note the use of `or` and `not`.

```bash
jq -c '.[]
  | {virtual, pool, vip, destination, rule: .rules[]}
  | select(.rule
           | startswith("X-Forwarded-For")
             or startswith("SomeRule")
             or startswith("AnotherRule")
           | not)' \
  f5data.json
```

## Group iRules by their target pool

Building on the previous examples of filtering out common rules, this example
groups the rules by the target pool.  The intent is to identify rules specific
to an application service.  The `rules` and `virtuals` arrays have duplicate
values removed using `unique()`.

Note, the `group_by` operator results in sorted output.

This is a real bear of a `jq` query, it hurt me brain to write it and it hurts
my brain to read it a couple days after the fact.  The command does the following to the data:

 1. Start with the external load balancer, `f5data.json` as input.
 2. Break the virtual server object into multiple objects, one per rule.
 3. Select common rules starting with certain prefixes.
 4. Filter out the rules selected using `not`.

Send this data to a second `jq` command which performs:

 1. Groups the array by the target pool.
 2. Aggregate each rule into `rules`, each virtual server into `virtuals`, and each vip into `vips`.
 3. De-duplicate the `rules`, `virtuals`, and `vips` arrays.

The result is a list of objects with the focus being the target pool instead of
the virtual server.  This focus on target pool may be more useful than the
focus on virtual server which is the default for `f5 map`.

```bash
jq -c '.[] | {virtual, pool, vip, destination, rule: .rules[]}
           | select(.rule
           | startswith("X-Forwarded-For")
             or startswith("SomeRule")
             or startswith("AnotherRule")
           | not)' f5data.json \
  | jq -sc 'group_by(.pool)
           | map(reduce .[] as $obj ({pool: .[0].pool}; .rules += [$obj.rule] | .virtuals += [$obj.virtual] | .vips += [$obj.vip])
           | .rules |= unique | .virtuals |= unique | .vips |= unique) | .[]'
```

# Other Commands

##  f5 irules

Output a simple list of names for all `ltm rule` configuration sections.  This
output includes rules which are not referenced in an active virtual server.
(i.e. defined, but inactive rules).

```
bundle exec f5 --format yaml --input f5rancid.conf irules | head -10
---
- SomeRule
- AnotherRule
```

## f5 virtuals

Output a simple list of names for all `ltm virtual` configuration sections.

```
bundle exec f5 --format yaml --input f5rancid.conf virtuals | head -10
---
- app1_http
- app1_https
```

## f5 pools

Output a simple list of names for all `ltm pool` configuration sections.  This
output includes pools which are not referenced in an active virtual server.
(i.e. defined, but inactive target pools).

```
bundle exec f5 --format yaml --input f5rancid.conf pools | head -10
- pool_app1
- pool_app2
```

[fixtures]: ./spec/fixtures/
[rules]: ./spec/fixtures/rules/
[rancid]: http://www.shrubbery.net/rancid/
